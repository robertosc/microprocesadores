
as12, an absolute assembler for Motorola MCU's, version 1.2h

                        ;##############################################################################
                        ;                                 Tarea #5
                        ;   Fecha: 3 de noviembre del 2020.
                        ;   Autor: Victor Yeom Song
                        ;
                        ;   Descripcion: este programa simula el conteo y empaquetado de tornillos
                        ;     en una linea de produccion. En el modo CONFIG se pueden definir
                        ;     cuantos tornillos incluye cada paquete (entre 12 y 96). En el modo RUN se
                        ;     simula el conteo de tornillos a una tasa de 4 tornillos por segundo y cuando
                        ;     la cuenta alcanza el valor programado se aumenta un acumulador de paquetes
                        ;     y se activa un relay dando asi indicacion de que el paquete esta completo.
                        ;##############################################################################
                        #include registers.inc
                        ; Memory maps and register equates
                        ; Choose one of DBUG12MAP (normal operation under DBUG12)
                        ;               EEPROMMAP  (DBUG12 in EEPROM mode)
                        ;               FLASHMAP   (Program loaded into Flash ROM)
0000                    DBUG12MAP equ 0        ; Memory mode is DBUG12MAP
                        ; EEPROMMAP equ 0         ; Memory mode is EEPROMMAP
                        #ifdef DBUG12MAP
0000                    REGBASE        equ        $0        ; register base
1000                    DATASTART equ        $1000        ; Start of data memory
2000                    DATAEND  equ        $2000        ; Stack pointer initial value (end of data RAM area)
2000                    PRSTART equ        $2000        ; Start of program memory (might be ROM)
3bff                    PREND        equ        $3BFF        ; End of program memory
                        
                        ; Functions in D-Bug12
ee84                    Getchar        equ        $EE84        ; Implemented in emulator
ee86                    Putchar equ        $EE86   ; Implemented in emulator
ee88                    Printf  equ     $EE88
ee8a                    GetCmdLine equ  $EE8A   ; FAR call
ee8e                    Sscanhex equ        $EE8E   ; FAR call
ee92                    Isxdigit equ    $EE92
ee94                    Toupper equ     $EE94
ee96                    Isalpha equ     $EE96
ee98                    Strlen  equ     $EE98
ee9a                    Strcpy  equ     $EE9A
ee9c                    Out2hex equ     $EE9C   ; FAR call
eea0                    Out4hex equ     $EEA0   ; FAR call
eea4                    SetUserVector equ $EEA4 ; No longer used
eea6                    WriteEEByte equ $EEA6   ; FAR call
eeaa                    EraseEE equ     $EEAA   ; FAR call
eeae                    ReadMem equ     $EEAE   ; FAR call
eeb2                    WriteMem equ    $EEB2   ; FAR call
                        
3e00                    VECTORTABLE equ $3E00        ; Vectors go here SHOULD ALSO INITIALIZE AT RUNTIME
0000                    STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
0000                    INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef EEPROMMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $3E00        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $400        ; Start of program memory
                        PREND        equ        $FFF        ; End of program memory
                        
                        VECTORTABLE equ $3E00        ; Vectors go here -- MUST BE INITIALIZED AT RUNTIME
                        INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef FLASHMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $4000        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $8000        ; Start of program memory
                        ; Note -- there are problems using the current free assemblers with paged memory
                        ; Best bet is to use logical addresses $8000 up only, set page register to 3E,
                        ; Change S1 records for $8000-BFFF to S2 records for page 3E and S1 records for $C000-$EFFF to
                        ; page 3F. Program startup vector goes in EFFE, and needs to be iin page 3F so PPAGE can be changed. 
                        PREND        equ        $EF7F        ; End of program memory
                        
                        VECTORTABLE equ $EF80        ; Vectors go here -- MUST BE INITIALIZED STATICALLY
                        STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
                        #endif
                        
                        
1000                    RAMSTART equ        DATASTART ; For compatibility
2000                    RAMEND equ        DATAEND   
                        
3e00                    UserRsrv0x80 equ (0*2)+VECTORTABLE
3e02                    UserRsrv0x82 equ (1*2)+VECTORTABLE
3e04                    UserRsrv0x84 equ (2*2)+VECTORTABLE
3e06                    UserRsrv0x86 equ (3*2)+VECTORTABLE
3e08                    UserRsrv0x88 equ (4*2)+VECTORTABLE
3e0a                    UserRsrv0x8a equ (5*2)+VECTORTABLE
3e0c                    UserPWMShDn equ (6*2)+VECTORTABLE
3e0e                    UserPortP equ (7*2)+VECTORTABLE
3e10                    UserMSCAN4Tx equ (8*2)+VECTORTABLE
3e12                    UserMSCAN4Rx equ (9*2)+VECTORTABLE
3e14                    UserMSCAN4Errs equ (10*2)+VECTORTABLE
3e16                    UserMSCAN4Wake equ (11*2)+VECTORTABLE
3e18                    UserMSCAN3Tx equ (12*2)+VECTORTABLE
3e1a                    UserMSCAN3Rx equ (13*2)+VECTORTABLE
3e1c                    UserMSCAN3Errs equ (14*2)+VECTORTABLE
3e1e                    UserMSCAN3Wake equ (15*2)+VECTORTABLE
3e20                    UserMSCAN2Tx equ (16*2)+VECTORTABLE
3e22                    UserMSCAN2Rx equ (17*2)+VECTORTABLE
3e24                    UserMSCAN2Errs equ (18*2)+VECTORTABLE
3e26                    UserMSCAN2Wake equ (19*2)+VECTORTABLE
3e28                    UserMSCAN1Tx equ (20*2)+VECTORTABLE
3e2a                    UserMSCAN1Rx equ (21*2)+VECTORTABLE
3e2c                    UserMSCAN1Errs equ (22*2)+VECTORTABLE
3e2e                    UserMSCAN1Wake equ (23*2)+VECTORTABLE
3e30                    UserMSCAN0Tx equ (24*2)+VECTORTABLE
3e32                    UserMSCAN0Rx equ (25*2)+VECTORTABLE
3e34                    UserMSCAN0Errs equ (26*2)+VECTORTABLE
3e36                    UserMSCAN0Wake equ (27*2)+VECTORTABLE
3e38                    UserFlash equ (28*2)+VECTORTABLE
3e3a                    UserEEPROM equ (29*2)+VECTORTABLE
3e3c                    UserSPI2 equ (30*2)+VECTORTABLE
3e3e                    UserSPI1 equ (31*2)+VECTORTABLE
3e40                    UserIIC equ (32*2)+VECTORTABLE
3e42                    UserDLC equ (33*2)+VECTORTABLE
3e44                    UserSCME equ (34*2)+VECTORTABLE
3e46                    UserCRG equ (35*2)+VECTORTABLE
3e48                    UserPAccBOv equ (36*2)+VECTORTABLE
3e4a                    UserModDwnCtr equ (37*2)+VECTORTABLE
3e4c                    UserPortH equ (38*2)+VECTORTABLE
3e4e                    UserPortJ equ (39*2)+VECTORTABLE
3e50                    UserAtoD1 equ (40*2)+VECTORTABLE
3e52                    UserAtoD0 equ (41*2)+VECTORTABLE
3e54                    UserSCI1 equ (42*2)+VECTORTABLE
3e56                    UserSCI0 equ (43*2)+VECTORTABLE
3e58                    UserSPI0 equ (44*2)+VECTORTABLE
3e5a                    UserPAccEdge equ (45*2)+VECTORTABLE
3e5c                    UserPAccOvf equ (46*2)+VECTORTABLE
3e5e                    UserTimerOvf equ (47*2)+VECTORTABLE
3e60                    UserTimerCh7 equ (48*2)+VECTORTABLE
3e62                    UserTimerCh6 equ (49*2)+VECTORTABLE
3e64                    UserTimerCh5 equ (50*2)+VECTORTABLE
3e66                    UserTimerCh4 equ (51*2)+VECTORTABLE
3e68                    UserTimerCh3 equ (52*2)+VECTORTABLE
3e6a                    UserTimerCh2 equ (53*2)+VECTORTABLE
3e6c                    UserTimerCh1 equ (54*2)+VECTORTABLE
3e6e                    UserTimerCh0 equ (55*2)+VECTORTABLE
3e70                    UserRTI equ (56*2)+VECTORTABLE
3e72                    UserIRQ equ (57*2)+VECTORTABLE
3e74                    UserXIRQ equ (58*2)+VECTORTABLE
3e76                    UserSWI equ (59*2)+VECTORTABLE
3e78                    UserTrap equ (60*2)+VECTORTABLE
                        
                        
                        *
                        *
                        *  HC12 i/o register locations (9s12dp256)
                        *
                        *
0000                    PORTA:          equ REGBASE+0   ;port a = address lines a8 - a15
0001                    PORTB:          equ REGBASE+1   ;port b = address lines a0 - a7
0002                    DDRA:           equ REGBASE+2   ;port a direction register
0003                    DDRB:           equ REGBASE+3   ;port b direction register
                        
0008                    PORTE:          equ REGBASE+8   ;port e = mode,irq and control signals
0009                    DDRE:           equ REGBASE+9   ;port e direction register
000a                    PEAR:           equ REGBASE+$a  ;port e assignments
000b                    MODE:           equ REGBASE+$b  ;mode register
000c                    PUCR:           equ REGBASE+$c  ;port pull-up control register
000d                    RDRIV:          equ REGBASE+$d  ;port reduced drive control register
000e                    EBICTL:                equ REGBASE+$e  ;e stretch control
                        
0010                    INITRM:         equ REGBASE+$10 ;ram location register
0011                    INITRG:         equ REGBASE+$11 ;register location register
0012                    INITEE:         equ REGBASE+$12 ;eeprom location register
0013                    MISC:           equ REGBASE+$13 ;miscellaneous mapping control
0014                    MTST0:          equ REGBASE+$14 ; reserved
0015                    ITCR:           equ REGBASE+$15 ;interrupt test control register
0016                    ITEST:          equ REGBASE+$16 ;interrupt test register
0017                    MTST1:          equ REGBASE+$17 ; reserved
                        
001a                    PARTIDH:        equ REGBASE+$1a ;part id high
001b                    PARTIDL:        equ REGBASE+$1b ;part id low
001c                    MEMSIZ0:        equ REGBASE+$1c ;memory size
001d                    MEMSIZ1:        equ REGBASE+$1d ;memory size
001e                    IRQCR:          equ REGBASE+$1e ;interrupt control register
001e                    INTCR:          equ REGBASE+$1e ;interrupt control register (old name)
001f                    HPRIO:          equ REGBASE+$1f ;high priority reg
                        
0028                    BKPCT0:         equ REGBASE+$28 ;break control register
0029                    BKPCT1:         equ REGBASE+$29 ;break control register
002a                    BKP0X:          equ REGBASE+$2a ; break 0 index register
002b                    BKP0H:          equ REGBASE+$2b ; break 0 pointer high
002c                    BRP0L:          equ REGBASE+$2c ; break 0 pointer low
002d                    BKP1X:          equ REGBASE+$2d ; break 1 index register
002e                    BKP1H:          equ REGBASE+$2e ; break 1 pointer high
002f                    BRP1L:          equ REGBASE+$2f ; break 1 pointer low
0030                    PPAGE:                equ REGBASE+$30 ;program page register
                        
0032                    PORTK:                equ REGBASE+$32 ;port k data
0033                    DDRK:                equ REGBASE+$33 ;port k direction
                        
0034                    SYNR:           equ REGBASE+$34 ; synthesizer / multiplier register
0035                    REFDV:          equ REGBASE+$35 ; reference divider register
0036                    CTFLG:          equ REGBASE+$36 ; reserved
0037                    CRGFLG:         equ REGBASE+$37 ; pll flags register
0038                    CRGINT:         equ REGBASE+$38 ; pll interrupt register
0039                    CLKSEL:         equ REGBASE+$39 ; clock select register
003a                    PLLCTL:         equ REGBASE+$3a ; pll control register
003b                    RTICTL:         equ REGBASE+$3b ;real time interrupt control
003c                    COPCTL:         equ REGBASE+$3c ;watchdog control
003d                    FORBYP:         equ REGBASE+$3d ;
003e                    CTCTL:          equ REGBASE+$3e ;
003f                    ARMCOP:         equ REGBASE+$3f ;cop reset register
                        
0040                    TIOS:           equ REGBASE+$40 ;timer input/output select
0041                    CFORC:          equ REGBASE+$41 ;timer compare force
0042                    OC7M:           equ REGBASE+$42 ;timer output compare 7 mask
0043                    OC7D:           equ REGBASE+$43 ;timer output compare 7 data
0044                    TCNT:           equ REGBASE+$44 ;timer counter register hi
                        *TCNT:          equ REGBASE+$45 ;timer counter register lo
0046                    TSCR:           equ REGBASE+$46 ;timer system control register (Old Name)
0046                    TSCR1:          equ REGBASE+$46 ;timer system control register
0047                    TTOV:           equ REGBASE+$47 ;reserved
0048                    TCTL1:          equ REGBASE+$48 ;timer control register 1
0049                    TCTL2:          equ REGBASE+$49 ;timer control register 2
004a                    TCTL3:          equ REGBASE+$4a ;timer control register 3
004b                    TCTL4:          equ REGBASE+$4b ;timer control register 4
004c                    TMSK1:          equ REGBASE+$4c ;timer interrupt mask 1 (Old Name)
004c                    TIE:            equ REGBASE+$4c ;timer interrupt mask 1
004d                    TMSK2:          equ REGBASE+$4d ;timer interrupt mask 2 (Old Name)
004d                    TSCR2:          equ REGBASE+$4d ;timer interrupt mask 2
004e                    TFLG1:          equ REGBASE+$4e ;timer flags 1
004f                    TFLG2:          equ REGBASE+$4f ;timer flags 2
0050                    TC0:            equ REGBASE+$50 ;timer capture/compare register 0
0052                    TC1:            equ REGBASE+$52 ;timer capture/compare register 1
0054                    TC2:            equ REGBASE+$54 ;timer capture/compare register 2
0056                    TC3:            equ REGBASE+$56 ;timer capture/compare register 3
0058                    TC4:            equ REGBASE+$58 ;timer capture/compare register 4
005a                    TC5:            equ REGBASE+$5a ;timer capture/compare register 5
005c                    TC6:            equ REGBASE+$5c ;timer capture/compare register 6
005e                    TC7:            equ REGBASE+$5e ;timer capture/compare register 7
0060                    PACTL:          equ REGBASE+$60 ;pulse accumulator controls
0061                    PAFLG:          equ REGBASE+$61 ;pulse accumulator flags
0062                    PACN3:          equ REGBASE+$62 ;pulse accumulator counter 3
0063                    PACN2:          equ REGBASE+$63 ;pulse accumulator counter 2
0064                    PACN1:          equ REGBASE+$64 ;pulse accumulator counter 1
0065                    PACN0:          equ REGBASE+$65 ;pulse accumulator counter 0
0066                    MCCTL:          equ REGBASE+$66 ;modulus down conunter control
0067                    MCFLG:          equ REGBASE+$67 ;down counter flags
0068                    ICPAR:          equ REGBASE+$68 ;input pulse accumulator control
0069                    DLYCT:          equ REGBASE+$69 ;delay count to down counter
006a                    ICOVW:          equ REGBASE+$6a ;input control overwrite register
006b                    ICSYS:          equ REGBASE+$6b ;input control system control
                        
006d                    TIMTST:         equ REGBASE+$6d ;timer test register
                        
0070                    PBCTL:          equ REGBASE+$70 ; pulse accumulator b control
0071                    PBFLG:          equ REGBASE+$71 ; pulse accumulator b flags
0072                    PA3H:           equ REGBASE+$72 ; pulse accumulator holding register 3
0073                    PA2H:           equ REGBASE+$73 ; pulse accumulator holding register 2
0074                    PA1H:           equ REGBASE+$74 ; pulse accumulator holding register 1
0075                    PA0H:           equ REGBASE+$75 ; pulse accumulator holding register 0
0076                    MCCNT:          equ REGBASE+$76 ; modulus down counter register
                        *MCCNTL:        equ REGBASE+$77 ; low byte
0078                    TCOH:           equ REGBASE+$78 ; capture 0 holding register
007a                    TC1H:           equ REGBASE+$7a ; capture 1 holding register
007c                    TC2H:           equ REGBASE+$7c ; capture 2 holding register
007e                    TC3H:           equ REGBASE+$7e ; capture 3 holding register
                        
0080                    ATD0CTL0:       equ REGBASE+$80 ;adc control 0 (reserved)
0081                    ATD0CTL1:       equ REGBASE+$81 ;adc control 1 (reserved)
0082                    ATD0CTL2:       equ REGBASE+$82 ;adc control 2
0083                    ATD0CTL3:       equ REGBASE+$83 ;adc control 3
0084                    ATD0CTL4:       equ REGBASE+$84 ;adc control 4
0085                    ATD0CTL5:       equ REGBASE+$85 ;adc control 5
0086                    ATD0STAT:       equ REGBASE+$86 ;adc status register hi
0086                    ATD0STAT0:      equ REGBASE+$86 ;adc status register hi
008b                    ATD0STAT1:      equ REGBASE+$8b ;adc status register lo
0088                    ATD0TEST:       equ REGBASE+$88 ;adc test (reserved)
                        *atd0test       equ REGBASE+$89 ;
                        
008d                    ATD0DIEN:        equ REGBASE+$8d ;
                        
008f                    PORTAD:         equ REGBASE+$8f ;port adc = input only
0090                    ADR00H:         equ REGBASE+$90 ;adc result 0 register
0092                    ADR01H:         equ REGBASE+$92 ;adc result 1 register
0094                    ADR02H:         equ REGBASE+$94 ;adc result 2 register
0096                    ADR03H:         equ REGBASE+$96 ;adc result 3 register
0098                    ADR04H:         equ REGBASE+$98 ;adc result 4 register
009a                    ADR05H:         equ REGBASE+$9a ;adc result 5 register
009c                    ADR06H:         equ REGBASE+$9c ;adc result 6 register
009e                    ADR07H:         equ REGBASE+$9e ;adc result 7 register
                        
00a0                    PWME:                equ REGBASE+$a0 ;pwm enable
00a1                    PWMPOL:         equ REGBASE+$a1 ;pwm polarity
00a2                    PWMCLK:         equ REGBASE+$a2 ;pwm clock select register
00a3                    PWMPRCLK:       equ REGBASE+$a3 ;pwm prescale clock select register
00a4                    PWMCAE:         equ REGBASE+$a4 ;pwm center align select register
00a5                    PWMCTL:         equ REGBASE+$a5 ;pwm control register
00a6                    PWMTST:         equ REGBASE+$a6 ;reserved
00a7                    PWMPRSC:        equ REGBASE+$a7 ;reserved
00a8                    PWMSCLA:        equ REGBASE+$a8 ;pwm scale a
00a9                    PWMSCLB:        equ REGBASE+$a9 ;pwm scale b
00aa                    PWMSCNTA:       equ REGBASE+$aa ;reserved
00ab                    PWMSCNTB:       equ REGBASE+$ab ;reserved
00ac                    PWMCNT0:        equ REGBASE+$ac ;pwm channel 0 counter
00ad                    PWMCNT1:        equ REGBASE+$ad ;pwm channel 1 counter
00ae                    PWMCNT2:        equ REGBASE+$ae ;pwm channel 2 counter
00af                    PWMCNT3:        equ REGBASE+$af ;pwm channel 3 counter
00b0                    PWMCNT4:        equ REGBASE+$b0 ;pwm channel 4 counter
00b1                    PWMCNT5:        equ REGBASE+$b1 ;pwm channel 5 counter
00b2                    PWMCNT6:        equ REGBASE+$b2 ;pwm channel 6 counter
00b3                    PWMCNT7:        equ REGBASE+$b3 ;pwm channel 7 counter
00b4                    PWMPER0:        equ REGBASE+$b4 ;pwm channel 0 period
00b5                    PWMPER1:        equ REGBASE+$b5 ;pwm channel 1 period
00b6                    PWMPER2:        equ REGBASE+$b6 ;pwm channel 2 period
00b7                    PWMPER3:        equ REGBASE+$b7 ;pwm channel 3 period
00b8                    PWMPER4:        equ REGBASE+$b8 ;pwm channel 4 period
00b9                    PWMPER5:        equ REGBASE+$b9 ;pwm channel 5 period
00ba                    PWMPER6:        equ REGBASE+$ba ;pwm channel 6 period
00bb                    PWMPER7:        equ REGBASE+$bb ;pwm channel 7 period
00bc                    PWMDTY0:        equ REGBASE+$bc ;pwm channel 0 duty cycle
00bd                    PWMDTY1:        equ REGBASE+$bd ;pwm channel 1 duty cycle
00be                    PWMDTY2:        equ REGBASE+$be ;pwm channel 2 duty cycle
00bf                    PWMDTY3:        equ REGBASE+$bf ;pwm channel 3 duty cycle
00c0                    PWMDTY4:        equ REGBASE+$c0 ;pwm channel 4 duty cycle
00c1                    PWMDTY5:        equ REGBASE+$c1 ;pwm channel 5 duty cycle
00c2                    PWMDTY6:        equ REGBASE+$c2 ;pwm channel 6 duty cycle
00c3                    PWMDTY7:        equ REGBASE+$c3 ;pwm channel 7 duty cycle
00c4                    PWMSDN:         equ REGBASE+$c4 ;pwm shutdown register
                        
00c8                    SC0BDH:         equ REGBASE+$c8 ;sci 0 baud reg hi byte
00c9                    SC0BDL:         equ REGBASE+$c9 ;sci 0 baud reg lo byte
00ca                    SC0CR1:         equ REGBASE+$ca ;sci 0 control1 reg
00cb                    SC0CR2:         equ REGBASE+$cb ;sci 0 control2 reg
00cc                    SC0SR1:         equ REGBASE+$cc ;sci 0 status reg 1
00cd                    SC0SR2:         equ REGBASE+$cd ;sci 0 status reg 2
00ce                    SC0DRH:         equ REGBASE+$ce ;sci 0 data reg hi
00cf                    SC0DRL:         equ REGBASE+$cf ;sci 0 data reg lo
                        
00d0                    SC1BDH:         equ REGBASE+$d0 ;sci 1 baud reg hi byte
00d1                    SC1BDL:         equ REGBASE+$d1 ;sci 1 baud reg lo byte
00d2                    SC1CR1:         equ REGBASE+$d2 ;sci 1 control1 reg
00d3                    SC1CR2:         equ REGBASE+$d3 ;sci 1 control2 reg
00d4                    SC1SR1:         equ REGBASE+$d4 ;sci 1 status reg 1
00d5                    SC1SR2:         equ REGBASE+$d5 ;sci 1 status reg 2
00d6                    SC1DRH:         equ REGBASE+$d6 ;sci 1 data reg hi
00d7                    SC1DRL:         equ REGBASE+$d7 ;sci 1 data reg lo
                        
00d8                    SPI0CR1:        equ REGBASE+$d8 ;spi 0 control1 reg
00d9                    SPI0CR2:        equ REGBASE+$d9 ;spi 0 control2 reg
00da                    SPI0BR:         equ REGBASE+$da ;spi 0 baud reg
00db                    SPI0SR:         equ REGBASE+$db ;spi 0 status reg hi
00dd                    SP0DR:          equ REGBASE+$dd ;spi 0 data reg  FOR COMPATIBILITY
00dd                    SPI0DR:          equ REGBASE+$dd ;spi 0 data reg
                        
00e0                    IBAD:                equ REGBASE+$e0 ;i2c bus address register
00e1                    IBFD:                equ REGBASE+$e1 ;i2c bus frequency divider
00e2                    IBCR:                equ REGBASE+$e2 ;i2c bus control register
00e3                    IBSR:                equ REGBASE+$e3 ;i2c bus status register
00e4                    IBDR:                equ REGBASE+$e4 ;i2c bus message data register
                        
00e8                    DLCBCR1:        equ REGBASE+$e8 ;bdlc control regsiter 1
00e9                    DLCBSVR:        equ REGBASE+$e9 ;bdlc state vector register
00ea                    DLCBCR2:        equ REGBASE+$ea ;bdlc control register 2
00eb                    DLCBDR:                equ REGBASE+$eb ;bdlc data register
00ec                    DLCBARD:        equ REGBASE+$ec ;bdlc analog delay register
00ed                    DLCBRSR:        equ REGBASE+$ed ;bdlc rate select register
00ee                    DLCSCR:                equ REGBASE+$ee ;bdlc control register
00ef                    DLCBSTAT:        equ REGBASE+$ef ;bdlc status register
                        
00f0                    SPI1CR1:        equ REGBASE+$f0 ;spi 1 control1 reg
00f1                    SPI1CR2:        equ REGBASE+$f1 ;spi 1 control2 reg
00f2                    SPI1BR:         equ REGBASE+$f2 ;spi 1 baud reg
00f3                    SPI1SR:         equ REGBASE+$f3 ;spi 1 status reg hi
00f5                    SPI1DR:          equ REGBASE+$f5 ;spi 1 data reg
00f5                    SP1DR:          equ REGBASE+$f5 ;spi 1 data reg   FOR COMPATIBILITY
                        
00f8                    SPI2CR1:        equ REGBASE+$f8 ;spi 2 control1 reg
00f9                    SPI2CR2:        equ REGBASE+$f9 ;spi 2 control2 reg
00fa                    SPI2BR:         equ REGBASE+$fa ;spi 2 baud reg
00fb                    SPI2SR:         equ REGBASE+$fb ;spi 2 status reg hi
00fd                    SPI2DR:         equ REGBASE+$fd ;spi 2 data reg
00fd                    SP2DR:          equ REGBASE+$fd ;spi 2 data reg   FOR COMPATIBILITY
                        
0100                    FCLKDIV:        equ REGBASE+$100 ;flash clock divider
0101                    FSEC:                equ REGBASE+$101 ;flash security register
                        
0103                    FCNFG:                equ REGBASE+$103 ;flash configuration register
0104                    FPROT:                equ REGBASE+$104 ;flash protection register
0105                    FSTAT:                equ REGBASE+$105 ;flash status register
0106                    FCMD:                equ REGBASE+$106 ;flash command register
                        
0110                    ECLKDIV:        equ REGBASE+$110 ;eeprom clock divider
                        
0113                    ECNFG:                equ REGBASE+$113 ;eeprom configuration register
0114                    EPROT:                equ REGBASE+$114 ;eeprom protection register
0115                    ESTAT:                equ REGBASE+$115 ;eeprom status register
0116                    ECMD:                equ REGBASE+$116 ;eeprom command register
                        
0120                    ATD1CTL0:       equ REGBASE+$120 ;adc1 control 0 (reserved)
0121                    ATD1CTL1:       equ REGBASE+$121 ;adc1 control 1 (reserved)
0122                    ATD1CTL2:       equ REGBASE+$122 ;adc1 control 2
0123                    ATD1CTL3:       equ REGBASE+$123 ;adc1 control 3
0124                    ATD1CTL4:       equ REGBASE+$124 ;adc1 control 4
0125                    ATD1CTL5:       equ REGBASE+$125 ;adc1 control 5
0126                    ATD1STAT0:      equ REGBASE+$126 ;adc1 status register hi
012b                    ATD1STAT1:      equ REGBASE+$12b ;adc1 status register lo
0128                    ATD1TEST:       equ REGBASE+$128 ;adc1 test (reserved)
                        *atd1test       equ REGBASE+$129 ;
                        
012d                    ATDDIEN:        equ REGBASE+$12d ;adc1 input enable register
                        
012f                    PORTAD1:        equ REGBASE+$12f ;port adc1 = input only
0130                    ADR10H:         equ REGBASE+$130 ;adc1 result 0 register
0132                    ADR11H:         equ REGBASE+$132 ;adc1 result 1 register
0134                    ADR12H:         equ REGBASE+$134 ;adc1 result 2 register
0136                    ADR13H:         equ REGBASE+$136 ;adc1 result 3 register
0138                    ADR14H:         equ REGBASE+$138 ;adc1 result 4 register
013a                    ADR15H:         equ REGBASE+$13a ;adc1 result 5 register
013c                    ADR16H:         equ REGBASE+$13c ;adc1 result 6 register
013e                    ADR17H:         equ REGBASE+$13e ;adc1 result 7 register
                        
0140                    CAN0CTL0:        equ REGBASE+$140 ;can0 control register 0
0141                    CAN0CTL1:        equ REGBASE+$141 ;can0 control register 1
0142                    CAN0BTR0:        equ REGBASE+$142 ;can0 bus timing register 0
0143                    CAN0BTR1:        equ REGBASE+$143 ;can0 bus timing register 1
0144                    CAN0RFLG:        equ REGBASE+$144 ;can0 receiver flags
0145                    CAN0RIER:        equ REGBASE+$145 ;can0 receiver interrupt enables
0146                    CAN0TFLG:        equ REGBASE+$146 ;can0 transmit flags
0147                    CAN0TIER:        equ REGBASE+$147 ;can0 transmit interrupt enables
0148                    CAN0TARQ:        equ REGBASE+$148 ;can0 transmit message abort control
0149                    CAN0TAAK:        equ REGBASE+$149 ;can0 transmit message abort status
014a                    CAN0TBEL:        equ REGBASE+$14a ;can0 transmit buffer select
014b                    CAN0IDAC:        equ REGBASE+$14b ;can0 identfier acceptance control
                        
014e                    CAN0RERR:        equ REGBASE+$14e ;can0 receive error counter
014f                    CAN0TERR:        equ REGBASE+$14f ;can0 transmit error counter
0150                    CAN0IDA0:        equ REGBASE+$150 ;can0 identifier acceptance register 0
0151                    CAN0IDA1:        equ REGBASE+$151 ;can0 identifier acceptance register 1
0152                    CAN0IDA2:        equ REGBASE+$152 ;can0 identifier acceptance register 2
0153                    CAN0IDA3:        equ REGBASE+$153 ;can0 identifier acceptance register 3
0154                    CAN0IDM0:        equ REGBASE+$154 ;can0 identifier mask register 0
0155                    CAN0IDM1:        equ REGBASE+$155 ;can0 identifier mask register 1
0156                    CAN0IDM2:        equ REGBASE+$156 ;can0 identifier mask register 2
0157                    CAN0IDM3:        equ REGBASE+$157 ;can0 identifier mask register 3
0158                    CAN0IDA4:        equ REGBASE+$158 ;can0 identifier acceptance register 4
0159                    CAN0IDA5:        equ REGBASE+$159 ;can0 identifier acceptance register 5
015a                    CAN0IDA6:        equ REGBASE+$15a ;can0 identifier acceptance register 6
015b                    CAN0IDA7:        equ REGBASE+$15b ;can0 identifier acceptance register 7
015c                    CAN0IDM4:        equ REGBASE+$15c ;can0 identifier mask register 4
015d                    CAN0IDM5:        equ REGBASE+$15d ;can0 identifier mask register 5
015e                    CAN0IDM6:        equ REGBASE+$15e ;can0 identifier mask register 6
015f                    CAN0IDM7:        equ REGBASE+$15f ;can0 identifier mask register 7
0160                    CAN0RXFG:        equ REGBASE+$160 ;can0 rx foreground buffer thru +$16f
0170                    CAN0TXFG:        equ REGBASE+$170 ;can0 tx foreground buffer thru +$17f
                        
0180                    CAN1CTL0:        equ REGBASE+$180 ;can1 control register 0
0181                    CAN1CTL1:        equ REGBASE+$181 ;can1 control register 1
0182                    CAN1BTR0:        equ REGBASE+$182 ;can1 bus timing register 0
0183                    CAN1BTR1:        equ REGBASE+$183 ;can1 bus timing register 1
0184                    CAN1RFLG:        equ REGBASE+$184 ;can1 receiver flags
0185                    CAN1RIER:        equ REGBASE+$185 ;can1 receiver interrupt enables
0186                    CAN1TFLG:        equ REGBASE+$186 ;can1 transmit flags
0187                    CAN1TIER:        equ REGBASE+$187 ;can1 transmit interrupt enables
0188                    CAN1TARQ:        equ REGBASE+$188 ;can1 transmit message abort control
0189                    CAN1TAAK:        equ REGBASE+$189 ;can1 transmit message abort status
018a                    CAN1TBEL:        equ REGBASE+$18a ;can1 transmit buffer select
018b                    CAN1IDAC:        equ REGBASE+$18b ;can1 identfier acceptance control
                        
018e                    CAN1RERR:        equ REGBASE+$18e ;can1 receive error counter
018f                    CAN1TERR:        equ REGBASE+$18f ;can1 transmit error counter
0190                    CAN1IDA0:        equ REGBASE+$190 ;can1 identifier acceptance register 0
0191                    CAN1IDA1:        equ REGBASE+$191 ;can1 identifier acceptance register 1
0192                    CAN1IDA2:        equ REGBASE+$192 ;can1 identifier acceptance register 2
0193                    CAN1IDA3:        equ REGBASE+$193 ;can1 identifier acceptance register 3
0194                    CAN1IDM0:        equ REGBASE+$194 ;can1 identifier mask register 0
0195                    CAN1IDM1:        equ REGBASE+$195 ;can1 identifier mask register 1
0196                    CAN1IDM2:        equ REGBASE+$196 ;can1 identifier mask register 2
0197                    CAN1IDM3:        equ REGBASE+$197 ;can1 identifier mask register 3
0198                    CAN1IDA4:        equ REGBASE+$198 ;can1 identifier acceptance register 4
0199                    CAN1IDA5:        equ REGBASE+$199 ;can1 identifier acceptance register 5
019a                    CAN1IDA6:        equ REGBASE+$19a ;can1 identifier acceptance register 6
019b                    CAN1IDA7:        equ REGBASE+$19b ;can1 identifier acceptance register 7
019c                    CAN1IDM4:        equ REGBASE+$19c ;can1 identifier mask register 4
019d                    CAN1IDM5:        equ REGBASE+$19d ;can1 identifier mask register 5
019e                    CAN1IDM6:        equ REGBASE+$19e ;can1 identifier mask register 6
019f                    CAN1IDM7:        equ REGBASE+$19f ;can1 identifier mask register 7
01a0                    CAN1RXFG:        equ REGBASE+$1a0 ;can1 rx foreground buffer thru +$1af
01b0                    CAN1TXFG:        equ REGBASE+$1b0 ;can1 tx foreground buffer thru +$1bf
                        
01c0                    CAN2CTL0:        equ REGBASE+$1c0 ;can2 control register 0
01c1                    CAN2CTL1:        equ REGBASE+$1c1 ;can2 control register 1
01c2                    CAN2BTR0:        equ REGBASE+$1c2 ;can2 bus timing register 0
01c3                    CAN2BTR1:        equ REGBASE+$1c3 ;can2 bus timing register 1
01c4                    CAN2RFLG:        equ REGBASE+$1c4 ;can2 receiver flags
01c5                    CAN2RIER:        equ REGBASE+$1c5 ;can2 receiver interrupt enables
01c6                    CAN2TFLG:        equ REGBASE+$1c6 ;can2 transmit flags
01c7                    CAN2TIER:        equ REGBASE+$1c7 ;can2 transmit interrupt enables
01c8                    CAN2TARQ:        equ REGBASE+$1c8 ;can2 transmit message abort control
01c9                    CAN2TAAK:        equ REGBASE+$1c9 ;can2 transmit message abort status
01ca                    CAN2TBEL:        equ REGBASE+$1ca ;can2 transmit buffer select
01cb                    CAN2IDAC:        equ REGBASE+$1cb ;can2 identfier acceptance control
                        
01ce                    CAN2RERR:        equ REGBASE+$1ce ;can2 receive error counter
01cf                    CAN2TERR:        equ REGBASE+$1cf ;can2 transmit error counter
01d0                    CAN2IDA0:        equ REGBASE+$1d0 ;can2 identifier acceptance register 0
01d1                    CAN2IDA1:        equ REGBASE+$1d1 ;can2 identifier acceptance register 1
01d2                    CAN2IDA2:        equ REGBASE+$1d2 ;can2 identifier acceptance register 2
01d3                    CAN2IDA3:        equ REGBASE+$1d3 ;can2 identifier acceptance register 3
01d4                    CAN2IDM0:        equ REGBASE+$1d4 ;can2 identifier mask register 0
01d5                    CAN2IDM1:        equ REGBASE+$1d5 ;can2 identifier mask register 1
01d6                    CAN2IDM2:        equ REGBASE+$1d6 ;can2 identifier mask register 2
01d7                    CAN2IDM3:        equ REGBASE+$1d7 ;can2 identifier mask register 3
01d8                    CAN2IDA4:        equ REGBASE+$1d8 ;can2 identifier acceptance register 4
01d9                    CAN2IDA5:        equ REGBASE+$1d9 ;can2 identifier acceptance register 5
01da                    CAN2IDA6:        equ REGBASE+$1da ;can2 identifier acceptance register 6
01db                    CAN2IDA7:        equ REGBASE+$1db ;can2 identifier acceptance register 7
01dc                    CAN2IDM4:        equ REGBASE+$1dc ;can2 identifier mask register 4
01dd                    CAN2IDM5:        equ REGBASE+$1dd ;can2 identifier mask register 5
01de                    CAN2IDM6:        equ REGBASE+$1de ;can2 identifier mask register 6
01df                    CAN2IDM7:        equ REGBASE+$1df ;can2 identifier mask register 7
01e0                    CAN2RXFG:        equ REGBASE+$1e0 ;can2 rx foreground buffer thru +$1ef
01f0                    CAN2TXFG:        equ REGBASE+$1f0 ;can2 tx foreground buffer thru +$1ff
                        
0200                    CAN3CTL0:        equ REGBASE+$200 ;can3 control register 0
0201                    CAN3CTL1:        equ REGBASE+$201 ;can3 control register 1
0202                    CAN3BTR0:        equ REGBASE+$202 ;can3 bus timing register 0
0203                    CAN3BTR1:        equ REGBASE+$203 ;can3 bus timing register 1
0204                    CAN3RFLG:        equ REGBASE+$204 ;can3 receiver flags
0205                    CAN3RIER:        equ REGBASE+$205 ;can3 receiver interrupt enables
0206                    CAN3TFLG:        equ REGBASE+$206 ;can3 transmit flags
0207                    CAN3TIER:        equ REGBASE+$207 ;can3 transmit interrupt enables
0208                    CAN3TARQ:        equ REGBASE+$208 ;can3 transmit message abort control
0209                    CAN3TAAK:        equ REGBASE+$209 ;can3 transmit message abort status
020a                    CAN3TBEL:        equ REGBASE+$20a ;can3 transmit buffer select
020b                    CAN3IDAC:        equ REGBASE+$20b ;can3 identfier acceptance control
                        
020e                    CAN3RERR:        equ REGBASE+$20e ;can3 receive error counter
020f                    CAN3TERR:        equ REGBASE+$20f ;can3 transmit error counter
0210                    CAN3IDA0:        equ REGBASE+$210 ;can3 identifier acceptance register 0
0211                    CAN3IDA1:        equ REGBASE+$211 ;can3 identifier acceptance register 1
0212                    CAN3IDA2:        equ REGBASE+$212 ;can3 identifier acceptance register 2
0213                    CAN3IDA3:        equ REGBASE+$213 ;can3 identifier acceptance register 3
0214                    CAN3IDM0:        equ REGBASE+$214 ;can3 identifier mask register 0
0215                    CAN3IDM1:        equ REGBASE+$215 ;can3 identifier mask register 1
0216                    CAN3IDM2:        equ REGBASE+$216 ;can3 identifier mask register 2
0217                    CAN3IDM3:        equ REGBASE+$217 ;can3 identifier mask register 3
0218                    CAN3IDA4:        equ REGBASE+$218 ;can3 identifier acceptance register 4
0219                    CAN3IDA5:        equ REGBASE+$219 ;can3 identifier acceptance register 5
021a                    CAN3IDA6:        equ REGBASE+$21a ;can3 identifier acceptance register 6
021b                    CAN3IDA7:        equ REGBASE+$21b ;can3 identifier acceptance register 7
021c                    CAN3IDM4:        equ REGBASE+$21c ;can3 identifier mask register 4
021d                    CAN3IDM5:        equ REGBASE+$21d ;can3 identifier mask register 5
021e                    CAN3IDM6:        equ REGBASE+$21e ;can3 identifier mask register 6
021f                    CAN3IDM7:        equ REGBASE+$21f ;can3 identifier mask register 7
0220                    CAN3RXFG:        equ REGBASE+$220 ;can3 rx foreground buffer thru +$22f
0230                    CAN3TXFG:        equ REGBASE+$230 ;can3 tx foreground buffer thru +$23f
                        
0240                    PTT:                equ REGBASE+$240 ;portt data register
0241                    PTIT:                equ REGBASE+$241 ;portt input register
0242                    DDRT:                equ REGBASE+$242 ;portt direction register
0243                    RDRT:                equ REGBASE+$243 ;portt reduced drive register
0244                    PERT:                equ REGBASE+$244 ;portt pull device enable
0245                    PPST:                equ REGBASE+$245 ;portt pull polarity select
                        
0248                    PTS:                equ REGBASE+$248 ;ports data register
0249                    PTIS:                equ REGBASE+$249 ;ports input register
024a                    DDRS:                equ REGBASE+$24a ;ports direction register
024b                    RDRS:                equ REGBASE+$24b ;ports reduced drive register
024c                    PERS:                equ REGBASE+$24c ;ports pull device enable
024d                    PPSS:                equ REGBASE+$24d ;ports pull polarity select
024e                    WOMS:                equ REGBASE+$24e ;ports wired or mode register
                        
0250                    PTM:                equ REGBASE+$250 ;portm data register
0251                    PTIM:                equ REGBASE+$251 ;portm input register
0252                    DDRM:                equ REGBASE+$252 ;portm direction register
0253                    RDRM:                equ REGBASE+$253 ;portm reduced drive register
0254                    PERM:                equ REGBASE+$254 ;portm pull device enable
0255                    PPSM:                equ REGBASE+$255 ;portm pull polarity select
0256                    WOMM:                equ REGBASE+$256 ;portm wired or mode register
0257                    MODRR:                equ REGBASE+$257 ;portm module routing register
                        
0258                    PTP:                equ REGBASE+$258 ;portp data register
0259                    PTIP:                equ REGBASE+$259 ;portp input register
025a                    DDRP:                equ REGBASE+$25a ;portp direction register
025b                    RDRP:                equ REGBASE+$25b ;portp reduced drive register
025c                    PERP:                equ REGBASE+$25c ;portp pull device enable
025d                    PPSP:                equ REGBASE+$25d ;portp pull polarity select
025e                    PIEP:                equ REGBASE+$25e ;portp interrupt enable register
025f                    PIFP:                equ REGBASE+$25f ;portp interrupt flag register
                        
0260                    PTH:                equ REGBASE+$260 ;porth data register
0261                    PTIH:                equ REGBASE+$261 ;porth input register
0262                    DDRH:                equ REGBASE+$262 ;porth direction register
0263                    RDRH:                equ REGBASE+$263 ;porth reduced drive register
0264                    PERH:                equ REGBASE+$264 ;porth pull device enable
0265                    PPSH:                equ REGBASE+$265 ;porth pull polarity select
0266                    PIEH:                equ REGBASE+$266 ;porth interrupt enable register
0267                    PIFH:                equ REGBASE+$267 ;porth interrupt flag register
                        
0268                    PTJ:                equ REGBASE+$268 ;portj data register
0269                    PTIJ:                equ REGBASE+$269 ;portj input register
026a                    DDRJ:                equ REGBASE+$26a ;portj direction register
026b                    RDRJ:                equ REGBASE+$26b ;portj reduced drive register
026c                    PERJ:                equ REGBASE+$26c ;portj pull device enable
026d                    PPSJ:                equ REGBASE+$26d ;portj pull polarity select
026e                    PIEJ:                equ REGBASE+$26e ;portj interrupt enable register
026f                    PIFJ:                equ REGBASE+$26f ;portj interrupt flag register
                        
0280                    CAN4CTL0:        equ REGBASE+$280 ;can4 control register 0
0281                    CAN4CTL1:        equ REGBASE+$281 ;can4 control register 1
0282                    CAN4BTR0:        equ REGBASE+$282 ;can4 bus timing register 0
0283                    CAN4BTR1:        equ REGBASE+$283 ;can4 bus timing register 1
0284                    CAN4RFLG:        equ REGBASE+$284 ;can4 receiver flags
0285                    CAN4RIER:        equ REGBASE+$285 ;can4 receiver interrupt enables
0286                    CAN4TFLG:        equ REGBASE+$286 ;can4 transmit flags
0287                    CAN4TIER:        equ REGBASE+$287 ;can4 transmit interrupt enables
0288                    CAN4TARQ:        equ REGBASE+$288 ;can4 transmit message abort control
0289                    CAN4TAAK:        equ REGBASE+$289 ;can4 transmit message abort status
028a                    CAN4TBEL:        equ REGBASE+$28a ;can4 transmit buffer select
028b                    CAN4IDAC:        equ REGBASE+$28b ;can4 identfier acceptance control
                        
028e                    CAN4RERR:        equ REGBASE+$28e ;can4 receive error counter
028f                    CAN4TERR:        equ REGBASE+$28f ;can4 transmit error counter
0290                    CAN4IDA0:        equ REGBASE+$290 ;can4 identifier acceptance register 0
0291                    CAN4IDA1:        equ REGBASE+$291 ;can4 identifier acceptance register 1
0292                    CAN4IDA2:        equ REGBASE+$292 ;can4 identifier acceptance register 2
0293                    CAN4IDA3:        equ REGBASE+$293 ;can4 identifier acceptance register 3
0294                    CAN4IDM0:        equ REGBASE+$294 ;can4 identifier mask register 0
0295                    CAN4IDM1:        equ REGBASE+$295 ;can4 identifier mask register 1
0296                    CAN4IDM2:        equ REGBASE+$296 ;can4 identifier mask register 2
0297                    CAN4IDM3:        equ REGBASE+$297 ;can4 identifier mask register 3
0298                    CAN4IDA4:        equ REGBASE+$298 ;can4 identifier acceptance register 4
0299                    CAN4IDA5:        equ REGBASE+$299 ;can4 identifier acceptance register 5
029a                    CAN4IDA6:        equ REGBASE+$29a ;can4 identifier acceptance register 6
029b                    CAN4IDA7:        equ REGBASE+$29b ;can4 identifier acceptance register 7
029c                    CAN4IDM4:        equ REGBASE+$29c ;can4 identifier mask register 4
029d                    CAN4IDM5:        equ REGBASE+$29d ;can4 identifier mask register 5
029e                    CAN4IDM6:        equ REGBASE+$29e ;can4 identifier mask register 6
029f                    CAN4IDM7:        equ REGBASE+$29f ;can4 identifier mask register 7
02a0                    CAN4RXFG:        equ REGBASE+$2a0 ;can4 rx foreground buffer thru +$2af
02b0                    CAN4TXFG:        equ REGBASE+$2b0 ;can4 tx foreground buffer thru +$2bf
                        
                        * end registers
                        #endinclude

                        
                        ;------------------------------------------------------------------------------
                        ;     Declaracion de las estructuras de datos y vectores de interrupcion
                        ;------------------------------------------------------------------------------
                        ;Vectores de interrupcion:
3e70                                   ORG $3E70   ;direccion del vector de interrupcion RTI.
3e70 24 58                             DW RTI_ISR  ;direccion de la subrutina de servicio a interrupcion RTI.
3e4c                                   ORG $3E4C   ;direccion del vector de interrupcion por key wakeup del puerto H.
3e4c 24 6c                             DW PTH_ISR  ;direccion de la subrutina de servicio a interrupcion del puerto H.
3e66                                   ORG $3E66   ;direccion del vector de interrupcion OC4.
3e66 24 ba                             DW OC4_ISR  ;direccion de la subrutina de servicio a interrupcion OC4.
                        
                        
                        ;Estructuras de datos:
1000                                    ORG $1000
1000                    Banderas:       DS 1  ;Tiene el formato: X:X:CAMBIO_MODO:MODSEL:X:ARRAY_OK:TCL_LEIDA:TCL_LISTA.
                                              ;ARRAY_OK indica que se presiono la tecla Enter y que en el arreglo ya se tienen todos los valores leidos.
                                              ;TCL_LEIDA indica que ya se habia tenido una lectura del teclado y que se estaba esperando a que se diera la supresion de rebotes.
                                              ;TCL_LISTA indica que luego de la supresion de rebotes se confirmo que si se presiono una tecla.
                                              ;MODSEL es el selector del modo, asociado al dipswitch PH7. Modo CONFIG en ON (1), modo RUN en OFF (0).
                                              ;CAMBIO_MODO cuando esta en 1 indica que se dio un cambio de modo y permite refrescar LCD.
1001 02                 MAX_TCL:        DB 2  ;cantidad maximas de teclas que se leen
1002                    Tecla:          DS 1  ;en esta variable se almacena el valor leido del teclado en la subrutina MUX_TECLADO.
1003                    Tecla_IN:       DS 1  ;en esta variable se almacena temporalmente el valor de Tecla antes de la supresion de rebotes. Si despues de la supresion se da que Tecla y Tecla_IN son iguales es porque efectivamente se presiono una tecla que debe ser guardada.
1004                    Cont_Reb:       DS 1  ;es el contador de ticks del RTI, usado para suprimir rebotes.
1005                    Cont_TCL:       DS 1  ;es el indice utilizado para escribir en el arreglo que guarda las teclas presionadas.
1006                    Patron:         DS 1  ;es el indice que lleva las iteraciones en subrutina MUX_TECLADO.
1007                    Num_Array:      DS 2  ;en este arreglo se almacenan todas las teclas presionadas por el usuario.
1009                    CUENTA:         DS 1  ;cantidad de tornillos contados para cada empaque.
100a                    AcmPQ:          DS 1  ;cantidad de empaques completados. Entre 0 y 99 y puede rebasar.
100b                    CantPQ:         DS 1  ;cantidad maxima de tornillos por cada empaque. Entre 12 y 96. Definido por usuario en MODO CONFIG.
100c                    TIMER_CUENTA:   DS 1  ;da la cedencia de incremento de CUENTA. Simula el paso de tornillos. Decrementada por RTI_ISR.
100d                    LEDS:           DS 1  ;guarda el estado de los LEDS. LED PB1 corresponde a modo CONFIG, LED PB0 a modo RUN.
100e                    BRILLO:         DS 1  ;Variable controlada por PTH3/PTH2 para incrementar/decrementar el brillo de la pantalla LCD.
100f                    CONT_DIG:       DS 1  ;cuenta cual digito de 7 segmentos se debe habilitar. Cambia cada vez que CONT_TICKS alcanza 100.
1010                    CONT_TICKS:     DS 1  ;contador de ticks de Output Compare para multiplexar.
                        
1011                    DT:             DS 1  ;ciclo de trabajo. DT = N-K.
1012                    BIN1:           DS 1  ;variable de entrada a subrutina CONV_BIN_BCD. Utilizada para CantPQ y CUENTA.
1013                    BIN2:           DS 1  ;variable de entrada a subrutina CONV_BIN_BCD. Utilizada para AcmPQ.
1014                    BCD_L:          DS 1  ;variable donde se guarda la salida de BIN_BCD. Utilizada para CONV_BIN_BCD.
1015                    LOW:            DS 1  ;variable requerida para el algoritmo de la subrutina BIN_BCD.
1016 f5                 VMAX:           DB 245 ;valor maximo de la variable TIMER_CUENTA. Usado para volver a iniciar la cuenta regresiva.
1017                    BCD1:           DS 1  ;variable de salida de subrutina BIN_BCD. Tambien es entrada para BCD_7SEG. Utilizada para CantPQ y CUENTA.
1018                    BCD2:           DS 1  ;variable de salida de subrutina BIN_BCD. Tambien es entrada para BCD_7SEG. Utilizada para AcmPQ.
1019                    DISP1:          DS 1  ;corresponde al valor que se escribe en el display de 7 segmentos.
101a                    DISP2:          DS 1  ;BCD2 utiliza DISP1 y DISP2 para desplegarse
101b                    DISP3:          DS 1  ;corresponde al valor que se escribe en el display de 7 segmentos.
101c                    DISP4:          DS 1  ;BCD1 utiliza DISP3 y DISP4 para desplegarse
                        
101d                    CONT_7SEG:      DS 2  ;contador de ticks de OC4 para lograr refrescamiento de LEDS y Displays a 10Hz.
101f                    Cont_Delay:     DS 1  ;esta variable se carga con alguna de las siguientes tres constantes para generar retrasos temporales.
1020 64                 D2ms:           DB 100  ;100 ticks a 50kHz son 2 milisegundos
1021 0d                 D260us:         DB 13  ;13 ticks a 50kHz son 260 microsegundos
1022 02                 D40us:          DB 2  ;2 ticks a 50kHz son 40 microsegundos
1023 01                 CLEAR_LCD:      DB $01  ;comando para limpiar el LCD
1024 80                 ADD_L1:         DB $80  ;direccion inicio de linea 1
1025 c0                 ADD_L2:         DB $C0  ;direccion inicio de linea 2
                        
1030                                    ORG $1030
1030 01 02 03 04 05 06  Teclas:         DB $01,$02,$03,$04,$05,$06,$07,$08,$09,$0B,$00,$0E ;valores de las teclas
     07 08 09 0b 00 0e
                        
1040                                    ORG $1040
1040 3f 06 5b 4f 66 6d  SEGMENT:        DB $3F,$06,$5B,$4F,$66,$6D,$7D,$07,$7F,$6F ;patrones para el display de 7 segmentos de los digitos de 0 a 9.
     7d 07 7f 6f
                        
1050                                    ORG $1050
1050 04 28 28 06 0c     iniDsp:         DB 4,FUNCTION_SET,FUNCTION_SET,ENTRY_MODE_SET,DISPLAY_ON
                        
1060                                    ORG $1060
                        ;LCD:
0028                    FUNCTION_SET:   EQU $28
0006                    ENTRY_MODE_SET: EQU $06
000c                    DISPLAY_ON:     EQU $0C
0001                    CLEAR_DISPLAY:  EQU $01
0002                    RETURN_HOME:    EQU $02
0080                    DDRAM_ADDR1:    EQU $80
00c0                    DDRAM_ADDR2:    EQU $C0
0000                    EOM:            EQU $00
                        
1070                                    ORG $1070 ;mensajes
1070 4d 4f 44 4f 20 43  CONFIG_MSG1:    FCC "MODO CONFIG"
     4f 4e 46 49 47
107b 00                                 DB EOM
107c 49 6e 67 72 65 73  CONFIG_MSG2:    FCC "Ingrese CantPQ:"
     65 20 43 61 6e 74
     50 51 3a
108b 00                                 DB EOM
108c 4d 4f 44 4f 20 52  RUN_MSG1:       FCC "MODO RUN"
     55 4e
1094 00                                 DB EOM
1095 41 63 6d 50 51 20  RUN_MSG2:       FCC "AcmPQ   CUENTA"
     20 20 43 55 45 4e
     54 41
10a3 00                                 DB EOM
                        ;------------------------------------------------------------------------------
                        
                        
                        
                        ;*******************************************************************************
                        ;                             Programa principal
                        ;*******************************************************************************
                        ;------------------------------------------------------------------------------
                        ;                          Configuracion del hardware
                        ;------------------------------------------------------------------------------
2000                        ORG $2000
                        ;Configuracion RTI:
2000 4c 38 80               BSET CRGINT %10000000 ;se habilita RTI
2003 18 0b 31 00 3b         MOVB #$31,RTICTL      ;periodo de 1.024 ms
                        
                        ;Configuracion keywakeup en puerto H:
2008 1c 02 66 0c            BSET PIEH %00001100   ;se habilita keywakeup en PH2 y PH3. Note que PH0 y PH1 se habilitan en modo RUN. PH7 es por polling.
200c 1d 02 65 ff            BCLR PPSH $FF   ;las interrupciones deben ocurrir en el flanco decreciente.
                        
                        ;Configuracion PH7 como entrada de proposito general por polling: (Dipswitch)
2010 1d 02 62 80            BCLR DDRH %10000000
                        
                        ;Configuracion del teclado en puerto A:
2014 18 0b f0 00 02         MOVB #$F0,DDRA        ;parte alta de A como salida y parte baja como entrada
2019 4c 0c 01               BSET PUCR %00000001   ;resistencias de pull-up en puerto A. Son necesarias para que haya un 1 en el PAD cuando no se presiona ningun boton del teclado.
                        
                        ;Configuracion del modulo de Timer como Output Compare en el Canal 4:
201c 4c 46 80               BSET TSCR1 %10000000 ;se habilita modulo de timer.
201f 4c 4d 03               BSET TSCR2 %00000011 ;prescaler es 2^3 = 8
2022 4c 40 10               BSET TIOS %00010000 ;se configura el canal 4 como Output Compare.
2025 4c 4c 10               BSET TIE %00010000 ;se habilita interrupcion del canal 4.
2028 4d 48 03               BCLR TCTL1 3 ;no es necesario que haya una salida en puerto T. Solo se requiere la interrupcion.
                        
                        ;Configuracion de los displays de 7 segmentos y los LEDS.
202b 18 0b ff 00 03         MOVB #$FF,DDRB ;puerto core B se configura como salida de proposito general. (LEDS y SEGMENTOS)
2030 18 0b 0f 02 5a         MOVB #$0F,DDRP ;parte baja de puerto P se configura como salida de proposito general. (~Habilitador Segmentos)
2035 1c 02 6a 02            BSET DDRJ %00000010 ;se configura bit 1 del puerto J como salida de proposito general . (~Habilitador LEDS)
                        
                        ;Configuracion de la salida SAL: relay en puerto PORTE4.
2039 18 0b 04 00 09         MOVB #$04,DDRE ;se configura PORTE4 como salida
                        
                        ;Configuracion de pantalla LCD
203e 18 0b ff 00 33         MOVB #$FF,DDRK ;todos los pines del puerto K se configura como salida para controlar la LCD.
                        
2043 10 ef                  CLI        ;habilita interrupciones mascarables.
                        ;------------------------------------------------------------------------------
                        ;                       Inicializacion de variables
                        ;------------------------------------------------------------------------------
2045 cf 3b ff               LDS #$3BFF  ;inicializa el stack
                        ;Teclado matricial:
2048 18 0b ff 10 02         MOVB #$FF,Tecla
204d 18 0b ff 10 03         MOVB #$FF,Tecla_IN
2052 18 0b ff 10 07         MOVB #$FF,Num_Array
2057 79 10 04               CLR Cont_Reb
205a 79 10 05               CLR Cont_TCL
205d 79 10 06               CLR Patron
                        
                        ;Displays de 7 segmentos y LEDS:
2060 79 10 1d               CLR CONT_7SEG
2063 79 10 10               CLR CONT_TICKS
2066 79 10 0f               CLR CONT_DIG
2069 18 0b 32 10 0e         MOVB #50,BRILLO
206e 18 0b 02 10 0d         MOVB #$02,LEDS
2073 79 10 17               CLR BCD1
2076 79 10 18               CLR BCD2
2079 18 0c 10 40 10 1b      MOVB SEGMENT,DISP3 ;para tener DISP3 produciendo un 0
207f 18 0c 10 40 10 1c      MOVB SEGMENT,DISP4 ;para tener DISP4 produciendo un 0. Importa mas que nada si se desea que en DISP3 y DISP4 presenten el ultimo valor valido introducido de CantPQ, con OC4
                        
                        ;Programa:
2085 79 10 0b               CLR CantPQ
2088 79 10 09               CLR CUENTA
208b 18 0c 10 16 10 0c      MOVB VMAX,TIMER_CUENTA
2091 79 10 0a               CLR AcmPQ
2094 79 10 00               CLR Banderas
2097 1c 10 00 10            BSET Banderas,%00010000 ;CambMod=1 (MODO_CONFIG)
                        
209b dc 44                  LDD TCNT ;se carga el valor actual de TCNT para reajustar el output compare
209d c3 00 3c               ADDD #60 ;60 cuentas equivalen 50kHz con prescalador=8
20a0 5c 58                  STD TC4 ;se actualiza el nuevo valor a alcanzar.
                            
20a2 ce 10 50                                   ldx #iniDsp
20a5 08                                         inx
20a6 c7                                         clrb
                        
20a7 a6 e5              INITIALIZE_LCD:         ldaa b,x
20a9 16 21 62                                   jsr Send_Command
20ac 18 0c 10 22 10 1f                          movb D40us,Cont_Delay
20b2 16 21 c2                                   jsr Delay
20b5 52                                         incb
20b6 f1 10 50                                   cmpb iniDsp
20b9 26 ec                                      bne INITIALIZE_LCD
20bb b6 10 23                                   ldaa CLEAR_LCD
20be 16 21 62                                   jsr Send_Command
20c1 18 0c 10 20 10 1f                          movb D2ms,Cont_Delay
20c7 16 21 c2                                   jsr Delay
                            
                            
                        ;------------------------------------------------------------------------------
20ca                    MAIN:
20ca f7 10 0b               TST CantPQ
20cd 27 56                  BEQ ESTADO_ZERO ;CantPQ=0? Ir a CONFIG
                            ;Revisamos si modsel==modactual
                            
20cf b6 02 61               LDAA PTIH
20d2 48                                 LSLA ;PTH7 esta en C
20d3 25 0f                              BCS MODSEL1 ;se revisa si MODSEL esta en 1
20d5 1f 10 00 08 26                     BRCLR Banderas %00001000 FIN_DETERMINE ;MODSEL es 0, se verifica por modo RUN
20da 1d 10 00 08                        BCLR Banderas %00001000 ;MODSEL es 0, se pone ModActual en Banderas en 0
20de 1c 10 00 10                        BSET Banderas %00010000 ;Se denota que hubo un cambio de modo con CambMod=1
20e2 20 0d                              BRA CLEAN_SCREEN ;se limpia la pantalla si hubo un cambio de modo
20e4                    MODSEL1:
20e4 1e 10 00 08 17                     BRSET Banderas %00001000 FIN_DETERMINE ;MODSEL es 1, se verifica por modo CONFIG
20e9 1c 10 00 08                        BSET Banderas %00001000 ;MODSEL es 1, se pone ModActual en Banderas en 1
20ed 1c 10 00 10                        BSET Banderas %00010000 ;Se denota que hubo un cambio de modo con CambMod=1
20f1                    CLEAN_SCREEN:
20f1 b6 10 23                           LDAA CLEAR_LCD ;cuando se cambia de modo, se limpia la pantalla
20f4 16 21 62                           JSR Send_Command ;envio de comando de limpieza de pantalla
20f7 18 0c 10 20 10 1f                  MOVB D2ms,Cont_Delay ;luego de enviar comando limpiar pantalla se debe esperar 2ms
20fd 16 21 c2                           JSR Delay
                        
2100 1e 10 00 08 24     FIN_DETERMINE:    BRSET Banderas %00001000 CONFIG_LCD ;ModActual=1? Ir a INIT_CONFIG
                        
2105                    RUN:
2105 1f 10 00 10 16         BRCLR Banderas %00010000 EX_RUN ;CambMod=0? Ir a EX_RUN
210a                    INIT_RUN:
210a 1c 02 66 03            BSET PIEH %00000011 ;habilita keywakeup para PH0 y PH1
210e 18 0b 01 10 0d         MOVB #$01,LEDS ;PB0=ON en modo config.
2113 ce 10 8c               LDX #RUN_MSG1
2116 cd 10 95               LDY #RUN_MSG2
2119 1d 10 00 10            BCLR Banderas %00010000 ;CambMod=0
211d 16 23 9d               JSR Cargar_LCD
2120                    EX_RUN:
2120 16 23 65               JSR MODO_RUN
2123 20 a5                  BRA MAIN
                        
2125 1c 10 00 08        ESTADO_ZERO:            bset Banderas,$08
                        
2129 4c 38 80           CONFIG_LCD:             bset CRGINT,$80 ;NO ES NECESARIA, CRGINT YA HABILITADAS
212c 1f 10 00 10 2b                             brclr Banderas,$10,CALL_CONFIG  ; Entra SOLO en primera iteraci?n
2131 1d 10 00 10                                bclr Banderas,$10 ; se pone cambio de modo en 0
                        
2135 1d 02 66 03                                bclr PIEH,$03     ;se deshabilitan puertos H 0 y 1
2139 1d 10 00 10                                bclr Banderas,$10
                        
213d ce 10 70                                   ldx #CONFIG_MSG1
2140 cd 10 7c                                   ldy #CONFIG_MSG2
                        
2143 79 10 09                                   clr CUENTA
2146 79 10 0a                                   clr AcmPQ
                        
2149 18 0b 00 00 08                             movb #$00,PORTE
214e 18 0b 02 10 0d                             movb #$02,LEDS ; enciende led pb1
                        
2153 18 0c 10 0b 10 12                          movb CantPQ,BIN1
                        
                                                ; CONFIGURACION PREVIA AL LCD, en primera iter entra ac?
                        
2159 16 23 9d                                   jsr CARGAR_LCD
                        
                        
                        
215c 16 23 31           CALL_CONFIG:            jsr MODO_CONFIG
                        
                        
215f 06 20 ca           volver_main:            jmp MAIN
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina Send_Command: se encarga de enviar al LCD el comando que recibe
                        ;     por el acumulador A.
                        ;------------------------------------------------------------------------------
2162                    Send_Command:
2162 36                                 PSHA ;el comando se recibe en acumulador A y se protege para poder analizar sus nibbles por separado
2163 84 f0                              ANDA #$F0 ;Se deja solo el nibble superior del comando a ejecutar
2165 44                                 LSRA
2166 44                                 LSRA ;se alinea nibble con bus datos en PORTK5-PORTK2.
2167 5a 32                              STAA PORTK ;se carga parte alta del comando en el bus de datos.
2169 4d 32 01                           BCLR PORTK,$01 ;Se habilita el envio de comandos.
216c 4c 32 02                           BSET PORTK,$02 ;Se habilita comunicacion con la LCD.
216f 18 0c 10 21 10 1f                  MOVB D260us,Cont_Delay ;se inicia el retardo de 260us.
2175 16 21 c2                           JSR Delay
2178 4d 32 02                           BCLR PORTK,$02 ;Se deshabilita comunicacion con la LCD
217b 32                                 PULA ;se recupera el comando original de la pila
217c 84 0f                              ANDA #$0F ;Se deja solo el nibble inferior del comando a ejecutar
217e 48                                 LSLA
217f 48                                 LSLA ;se alinea nibble con bus datos en PORTK5-PORTK2.
2180 5a 32                              STAA PORTK ;se carga parte baja del comando en el bus de datos.
2182 4d 32 01                           BCLR PORTK,$01 ;Se habilita el envio de comandos.
2185 4c 32 02                           BSET PORTK,$02 ;Se habilita comunicacion con la LCD.
2188 18 0c 10 21 10 1f                  MOVB D260us,Cont_Delay ;se inicia el retardo de 260us.
218e 16 21 c2                           JSR Delay
2191 4d 32 02                           BCLR PORTK,$02 ;Se deshabilita comunicacion con la LCD
2194 3d                                 RTS
                        ;------------------------------------------------------------------------------
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina Send_Data: se encarga de enviar al LCD el dato que recibe
                        ;     por el acumulador A.
                        ;------------------------------------------------------------------------------
2195                    Send_Data:
2195 36                                 PSHA ;el dato se recibe en acumulador A y se protege para poder analizar sus nibbles por separado
2196 84 f0                              ANDA #$F0 ;Se deja solo el nibble superior del dato
2198 44                                 LSRA
2199 44                                 LSRA ;se alinea nibble con bus datos en PORTK5-PORTK2.
219a 5a 32                              STAA PORTK ;se carga parte alta del dato en el bus de datos.
219c 4c 32 03                           BSET PORTK,$03 ;Se habilita el envio de dato y comunicacion con la LCD
219f 18 0c 10 21 10 1f                  MOVB D260us,Cont_Delay ;se inicia el retardo de 260us
21a5 16 21 c2                           JSR Delay
21a8 4d 32 02                           BCLR PORTK,$02 ;Se deshabilita comunicacion con la LCD
21ab 32                                 PULA ;se recupera el dato original de la pila
21ac 84 0f                              ANDA #$0F ;Se deja solo el nibble inferior del dato
21ae 48                                 LSLA
21af 48                                 LSLA ;se alinea nibble con bus datos en PORTK5-PORTK2.
21b0 5a 32                              STAA PORTK ;se carga parte baja del dato en el bus de datos.
21b2 4c 32 03                           BSET PORTK,$03 ;Se habilita envio de datos y comunicacion con la LCD
21b5 18 0c 10 21 10 1f                  MOVB D260us,Cont_Delay ;se inicia el retardo de 260us.
21bb 16 21 c2                           JSR Delay
21be 4d 32 02                           BCLR PORTK,$02 ;Se deshabilita comunicacion con la LCD
21c1 3d                                 RTS
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina INIT_LCD: se encarga de inicializar la pantalla LCD ejecutando la
                        ;     secuencia correcta de comandos.
                        ;------------------------------------------------------------------------------
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina Delay: se mantiene en un loop cerrado hasta que Cont_Delay sea 0.
                        ;     Cont_Delay es descontado por OC4 a 50 kHz.
                        ;------------------------------------------------------------------------------
21c2                    Delay:
21c2 f7 10 1f                           TST Cont_Delay
21c5 26 fb                              BNE Delay
21c7 3d                                 RTS
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina DETERMINE_MODE: esta subrutina calcula el estado de las banderas
                        ;     ModActual y CambMod cuando se verifica si MODSEL=ModActual.
                        ;------------------------------------------------------------------------------
                        
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina BCD_BIN: el arreglo Num_Array corresponde a un numero en BCD donde
                        ;     cada entrada es un digito. Esta subrutina toma este arreglo y calcula en
                        ;     binario el valor numerico del arreglo. El resultado se almacena en CantPQ.
                        ;------------------------------------------------------------------------------
21c8 ce 10 07           BCD_BIN:        ldx #Num_Array
21cb e6 01                              ldab 1,x
21cd c1 ff                              cmpb #$FF
21cf 27 05                              beq UNIDAD
21d1 7b 10 0b                           stab CantPQ
21d4 20 07                              bra DECENA
                        
21d6 18 0c 10 07 10 0b  UNIDAD:         movb Num_Array,CantPQ
21dc 3d                                 rts
                        
21dd 87                 DECENA:                clra
21de f6 10 07                           ldab Num_Array
21e1 cd 00 0a                           ldy #10
21e4 13                                 emul
                        
21e5 fb 10 0b                           addb CantPQ
21e8 7b 10 0b                           stab CantPQ
                        
21eb 3d                                 rts
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina BIN_BCD: esta subrutina realiza la conversion de un numero
                        ;     binario entre 0 y 99 (inclusivos) a su representacion en BCD. El numero
                        ;     a convertir se recibe como parametro por el registro A. El resultado en
                        ;     BCD se devuelve por la variable BCD_L, donde el nibble mas significativo son
                        ;     las decenas y el menos significativo las unidades.
                        ;------------------------------------------------------------------------------
21ec                    BIN_BCD:
                        
21ec c6 07                      Ldab #7  ; Contador B=15
21ee 79 10 14                   Clr BCD_L
                        
21f1 48                 lazo    Lsla
21f2 75 10 14                   Rol BCD_L  ;Lo mismo para la variable BCD_L y BCD_H
21f5 36                         Psha
                        
21f6 b6 10 14                   Ldaa BCD_L ;Cargamos en A el BCD_L
21f9 84 0f                      Anda #$0F  ;Tomamos solo en cuenta los 4LSB
21fb 81 05                      Cmpa #5   ;Comparamos con 5
21fd 25 02                      Blo men031  ;Si es menor, salte a men031
21ff 8b 03                      Adda #3  ;En caso de mayor, sume 3
                        
2201 7a 10 15           men031  Staa LOW  ;Guardamos temporalmente el resultado anterior
                        
2204 b6 10 14                   Ldaa BCD_L
2207 84 f0                      Anda #$F0 ;En A tenemos cargado del bit 4 al 7
2209 81 50                      Cmpa #$50  ;Comparamos con $50
220b 25 02                      Blo men301
220d 8b 30                      Adda #$30   ;Si es mayor, sume 30
                        
220f bb 10 15           men301  Adda LOW   ;Se suman los bits para obtener los 4 LSB de resultado
2212 7a 10 14                   Staa BCD_L  ;Se guarda el resultado
2215 32                         Pula
2216 04 31 d8                   Dbne b, lazo
                        
2219 48                         Lsla
221a 75 10 14                   Rol BCD_L
                        
221d 3d                         Rts
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina CONV_BIN_BCD: recibe como parametros de entrada las variables BIN1 y
                        ;     BIN2 y realiza la conversion a BCD de cada una de estas variables. La
                        ;     conversion de BIN2 solo se da en el modo RUN puesto que es el unico modo
                        ;     en el que BIN2 tiene valores relevantes. Ademas, luego de la conversion, si
                        ;     el numero es menor que 10 significa que el display de 7 segmentos utilizado
                        ;     para las decenas no es necesario que este encendido; en este caso se escribe
                        ;     $B en el nibble mas significativo de BCD1 y BCD2 para indicarlo.
                        ;------------------------------------------------------------------------------
221e                    CONV_BIN_BCD:
221e b6 10 12                           Ldaa BIN1
2221 16 21 ec                           Jsr BIN_BCD
2224 b6 10 14                           Ldaa BCD_L
2227 81 0a                              Cmpa #10
2229 24 02                              Bhs mayor1
222b 8b b0                              Adda #$B0
                        
222d 7a 10 17           mayor1          Staa BCD1
                                        ;Esto lo tiene el de victor pero no se si es necesario
                                        ;BRSET Banderas %00001000 FIN_BIN_BCD ;en modo CONFIG (ModActual=1) no es necesario convertir BIN2
                                        ;------------------------------------------
2230 b6 10 13                           Ldaa BIN2
2233 16 21 ec                           Jsr BIN_BCD
2236 b6 10 14                           Ldaa BCD_L
2239 81 0a                              Cmpa #10
223b 24 02                              Bhs mayor2
223d 8b b0                              Adda #$B0
                        
223f 7a 10 18           mayor2          Staa BCD2
2242 3d                                 Rts
                        
                        ;------------------------------------------------------------------------------
                        ; Subrutina TAREA_TECLADO: En esta subrutina se da la lectura del teclado. Aqui
                        ;     se lee el teclado en el puerto A, se suprimen los rebotes, y se maneja la
                        ;     situacion de tecla retenida.
                        ;------------------------------------------------------------------------------
2243                    TAREA_TECLADO:
2243 b6 10 04                   Ldaa Cont_Reb
2246 81 00                      Cmpa #0
2248 26 4a                      Bne RETORNAR
224a 16 22 95                   Jsr MUX_TECLADO
224d b6 10 02                   Ldaa Tecla
2250 81 ff                      Cmpa #$FF
2252 26 0e                      Bne PRESIONADA
2254 1f 10 00 01 3b             Brclr Banderas,$01,RETORNAR                 ; Si TCL_LISTA es 0, no hay tecla que registrar por lo que se termina la subrutina
2259 1d 10 00 03                Bclr Banderas,#$03                         ; Caso contrario se registra la tecla. Se ponen en 0 TCL_LISTA y TCL_LEIDA para la siguiente tecla
225d 16 22 cb                   Jsr FORMAR_ARRAY
2260 20 32                      Bra RETORNAR
                        
2262                    PRESIONADA:
2262 1f 10 00 02 0e             Brclr Banderas,$02,NotProc
2267 b6 10 03                   Ldaa Tecla_IN
226a b1 10 02                   Cmpa Tecla
226d 26 17                      Bne Delete
226f 1c 10 00 01                Bset Banderas,$01                         ; La tecla esta lista para registro
2273 20 1f                      bra RETORNAR
                        
                        
                        
2275                    NotProc:
2275 18 0c 10 02 10 03          Movb Tecla, Tecla_IN
227b 1c 10 00 02                Bset Banderas, #2
227f 18 0b 0a 10 04             Movb #10,Cont_Reb
2284 20 0e                      Bra RETORNAR
                        
2286 18 0b ff 10 02     DELETE: Movb #$FF,Tecla
228b 18 0b ff 10 03             Movb #$FF,Tecla_IN
2290 1d 10 00 03                Bclr Banderas, #3
                        
2294                    RETORNAR:
2294 3d                         RTS
                        
                        
                        ;------------------------------------------------------------------------------
2295 18 0b ef 10 06     MUX_TECLADO:    movb #$EF,Patron                ; Patron inicial
229a cc f0 00                           ldd #$F000                       ; final cuando se desplaza patron
                        
229d 18 0c 10 06 00 00  BUSCAR_COLUMNA: movb Patron,PORTA
22a3 4f 00 08 18                        brclr PORTA,$08,columna2            ; Verificamos se la tecla est? en la columna2
22a7 4f 00 04 15                        brclr PORTA,$04,columna1
22ab 4f 00 02 12                        brclr PORTA,$02,columna0
22af 78 10 06                           lsl Patron                          ; Se desplaza el patron para verificar siguiente fila
22b2 cb 03                              addb #3                             ; Se suman 3 para aumentar esa cantidad en el array de posibilidades
22b4 b1 10 06                           cmpa Patron
22b7 26 e4                              bne BUSCAR_COLUMNA
22b9 18 0b ff 10 02                     movb #$FF,Tecla
22be 3d                 TERMINAR:       rts
                        
22bf 52                 columna2:       incb                                ; Incrementa en 2 si salta ac?
22c0 52                 columna1:       incb                                ; Incrementa en 1 si salta ac?
22c1 ce 10 30           columna0:       ldx #Teclas
22c4 18 0d e5 10 02                     movb B,X,Tecla                      ; Se mueve la tecla encontrada
22c9 20 f3                              bra TERMINAR
                        
                        ;------------------------------------------------------------------------------
22cb b6 10 03           FORMAR_ARRAY:   ldaa Tecla_IN                   ; valor ingresado
22ce f6 10 05                           ldab Cont_TCL                   ; cantidad de numeros
22d1 ce 10 07                           ldx #Num_Array                   ; Posici?n del array
                        
22d4 f1 10 01                           cmpb MAX_TCL                    ; comparamos si ya est? lleno
22d7 27 13                              beq ARRAY_LLENO
22d9 c1 00                              cmpb #0                         ; vemos si est? vac?o
22db 27 2a                              beq PRIMER_VAL
22dd 81 0b                              cmpa #$0B                       ; tecla borrar
22df 27 42                              beq BORRAR
22e1 81 0e                              cmpa #$0E                       ; tecla enter
22e3 27 34                              beq ENTER
22e5 6a e5                              staa b,x                        ; guarda en Num_array + cont_TCL
22e7 72 10 05                           inc Cont_TCL
22ea 20 3f                              bra end_formar
                        
22ec 81 0b              ARRAY_LLENO:    cmpa #$0B
22ee 26 0a                              bne ARRAY_LLENO_1
22f0 53                                 decb
22f1 18 08 e5 ff                        movb #$FF,b,x                    ; Para borrar reemplazamos valor actual con ff
22f5 73 10 05                           dec Cont_TCL
22f8 20 31                              bra end_formar
                        
22fa 81 0e              ARRAY_LLENO_1:  cmpa #$0E                         ; es enter?
22fc 26 2d                              bne end_formar
22fe 1c 10 00 04                        bset Banderas,$04                ; bandera de array ok
2302 79 10 05                           clr Cont_TCL                     ; vac?a contador tc
2305 20 24                              bra end_formar
                        
2307 81 0b              PRIMER_VAL:     cmpa #$0B
2309 27 20                              beq end_formar                         ; terminar
                        
230b 81 0e              PRIMER_VAL_1:   cmpa #$0E
230d 27 1c                              beq end_formar
230f 18 09 e5 10 03                     movb Tecla_IN,b,x
2314 72 10 05                           inc Cont_TCL
2317 20 12                              bra end_formar
                        
2319 1c 10 00 04        ENTER:          bset Banderas,#$04                    ; bandera de array_ok
231d 1d 10 05 ff                        bclr Cont_TCL,#$FF                    ; pone contador en 0
2321 20 08                              bra end_formar
                        
                        
2323 73 10 05           BORRAR:         dec Cont_TCL
2326 53                                 decb
2327 18 08 e5 ff                        movb #$FF,b,x
                        
                        
232b 18 0b ff 10 03     end_formar:     movb #$FF,Tecla_IN
2330 3d                                 rts
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina MODO_CONFIG: Esta subrutina corresponde a las operaciones necesarias
                        ;     llevar a cabo la configuracion del sistema. Primero pone el valor adecuado
                        ;     de los LEDS para que el usuario pueda saber el modo. Posteriormente, con
                        ;     el uso de TAREA_TECLADO se da la lectura del valor CantPQ. Una vez que el
                        ;     usuario presiona ENTER se valida que el valor de CantPQ este entre 20 y 90.
                        ;     Si es asi entonces coloca este valor en BIN1 para que pueda ser desplegado
                        ;     en los displays 3 y 4. Cuando el valor no es valido se borra CantPQ.
                        ;------------------------------------------------------------------------------
2331 18 0c 10 0b 10 12  MODO_CONFIG:            movb CantPQ, BIN1
2337 1e 10 00 04 04                             brset Banderas,$04,DATA_CHECK
233c 16 22 43                                   jsr TAREA_TECLADO
233f 3d                                         rts
2340 16 21 c8           DATA_CHECK:             jsr BCD_BIN
2343 86 19                                      ldaa #25
2345 b1 10 0b                                   cmpa CantPQ
2348 2e 07                                      bgt INVALIDO
234a 86 55                                      ldaa #85
234c b1 10 0b                                   cmpa CantPQ
234f 2c 09                                      bge VALIDO
                        
2351 1d 10 00 04        INVALIDO:               bclr Banderas,$04
2355 1d 10 0b ff                                bclr CantPQ,$FF
2359 3d                                         rts
                        
235a 1d 10 00 04        VALIDO:                        bclr Banderas, $04
235e 18 0c 10 0b 10 12                          movb CantPQ,BIN1
2364 3d                                         rts
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina MODO_RUN: esta subrutina se encarga de simular el conteo de
                        ;     tornillos a 4Hz por medio del contador de ticks TIMER_CUENTA. Los tornillos
                        ;     se cuentan en la variable CUENTA y cuando esta alcanza CantPQ se enciende
                        ;     el relay en el puerto PORTE4, ademas de incrementar AcmPQ para mostrar que
                        ;     se termino otro paquete. No se permite que AcmPQ supere un valor de 99.
                        ;------------------------------------------------------------------------------
2365                    MODO_RUN:
2365 f7 10 0c                           Tst TIMER_CUENTA ;si timer cuenta es cero
2368 26 26                              Bne Fin_Run ;si no lo es, se retorna
                                        ;Caso en que timer cuenta es cero
236a 18 0c 10 16 10 0c                  Movb VMAX,TIMER_CUENTA ;se recarga con vmax
2370 72 10 09                           Inc CUENTA ;incrementamos cuenta
2373 b6 10 09                           Ldaa CUENTA ;
2376 b1 10 0b                           Cmpa CantPQ ;
2379 26 15                              Bne Fin_Run ;si cant!=cuenta
237b 72 10 0a                           Inc AcmPQ ;se incrementa AcmPQ
237e 4d 38 80                           Bclr CRGINT %10000000 ;se deshabilitamos RTI
2381 18 0b 04 00 08                     Movb #$04,PORTE ;se activa el relay
2386 86 64                              Ldaa #100
2388 b1 10 0a                           Cmpa AcmPQ ;se ve si AcmPQ ha llegado a 100 por rebase
238b 26 03                              Bne Fin_Run ;si no se ha llegado a 100, retorna
238d 79 10 0a                           CLR AcmPQ ;si se llega a 100, se hace rebase
2390                    Fin_Run:
2390 18 0c 10 09 10 12                  MOVB CUENTA,BIN1
2396 18 0c 10 0a 10 13                  MOVB AcmPQ,BIN2
239c 3d                                 RTS
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina Cargar_LCD: esta subrutina se encarga de enviar a la pantalla LCD
                        ;     cada caracter, uno por uno, de ambas lineas del LCD. Recibe los parametros
                        ;     en los registros indice X y Y, que contienen las direcciones de inicio a
                        ;     los mensajes de las lineas 1 y 2 respectivamente.
                        ;------------------------------------------------------------------------------
239d b6 10 24           Cargar_LCD:     ldaa ADD_L1
23a0 16 21 62                           jsr Send_Command
23a3 18 0c 10 22 10 1f                  movb D40uS,Cont_Delay
23a9 16 21 c2                           jsr Delay
                        
23ac a6 30              LINEA1:         ldaa 1,x+ ;Se va cargando mensaje
23ae 81 00                              cmpa #$00
23b0 27 0e                              beq CARGAR_LINEA2
                        
23b2 16 21 95                           jsr Send_Data
                        
23b5 18 0c 10 22 10 1f                  movb D40uS,Cont_Delay
23bb 16 21 c2                           jsr Delay
23be 20 ec                              bra LINEA1
                        
                        
23c0 b6 10 25           CARGAR_LINEA2:  ldaa ADD_L2
23c3 16 21 62                           jsr Send_Command
23c6 18 0c 10 22 10 1f                  movb D40uS,Cont_Delay
23cc 16 21 c2                           jsr Delay
                        
                        
23cf a6 70              LINEA2:         ldaa 1,y+
23d1 81 00                              cmpa #$00
23d3 27 0e                              beq TERMINA_LCD
23d5 16 21 95                           jsr Send_Data
23d8 18 0c 10 22 10 1f                  movb D40uS,Cont_Delay
23de 16 21 c2                           jsr Delay
23e1 20 ec                              bra LINEA2
                        
23e3 3d                 TERMINA_LCD:    rts
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina BCD_7SEG: esta subrutina se encarga de tomar los valores en BCD1
                        ;     y BCD2 y determinar el valor de DISP1, DISP2, DISP3, DISP4. Estas ultimas
                        ;     cuatro variables son las que indican cuales segmentos de los displays se
                        ;     deben encender para que se muestre el numero deseado. Sencillamente se
                        ;     se analiza cada nibble de BCD1 y BCD2, y se toman decisiones a partir de
                        ;     sus valores. En modo CONFIG (MODSEL=1) se apagan DISP1 y DISP2. Cuando
                        ;     CPROG=0 se tiene la excepcion que se quieren desplegar ambos ceros
                        ;------------------------------------------------------------------------------
23e4                    BCD_7SEG:
23e4 f7 10 0b                           TST CantPQ
23e7 26 14                              BNE CONVERSION ;cuando CPROG es cero se deben forzar al display ambos ceros.
23e9 79 10 19                           CLR DISP1 ;apaga displays de ACUMUL
23ec 79 10 1a                           CLR DISP2 ;apaga displays de ACUMUL
23ef 18 0c 10 40 10 1b                  MOVB SEGMENT,DISP3 ;fuerza el cero en displays de CUENTA
23f5 18 0c 10 40 10 1c                  MOVB SEGMENT,DISP4 ;fuerza el cero en displays de CUENTA. Si se quisiera poner el ultimo valor valido, se borran estas 2 lineas
23fb 20 5a                              BRA FIN_BCD_7SEG
                        
23fd                    CONVERSION:
23fd ce 10 40                           LDX #SEGMENT ;direccion base de los valores para escribir en el puerto B.
2400 c6 0f                              LDAB #$0F ;mascara para nibble menos significativo
2402 86 f0                              LDAA #$F0 ;mascara para nibble mas significativo
2404 f4 10 17                           ANDB BCD1 ;se extrae el nibble menos significativo de BCD1.
2407 18 0d e5 10 1c                     MOVB B,X,DISP4
240c b4 10 17                           ANDA BCD1 ;se extrae el nibble mas significativo de BCD1.
240f 81 b0                              CMPA #$B0
2411 27 0b                              BEQ DISP3_OFF ;cuando el nibble mas significativo es $B se debe apagar el DISP3
2413 44                                 LSRA
2414 44                                 LSRA
2415 44                                 LSRA
2416 44                                 LSRA ;se traslada el nibble mas significativo a la parte baja del byte.
2417 18 0d e4 10 1b                     MOVB A,X,DISP3
241c 20 05                              BRA AHORA_BCD2
241e                    DISP3_OFF:
241e 18 0b 00 10 1b                     MOVB #$00,DISP3
                        
2423                    AHORA_BCD2:
2423 1e 10 00 08 25                     BRSET Banderas %00001000 NO_BCD2
2428 c6 0f                              LDAB #$0F ;mascara para nibble menos significativo
242a 86 f0                              LDAA #$F0 ;mascara para nibble mas significativo
242c f4 10 18                           ANDB BCD2 ;se extrae el nibble menos significativo de BCD1.
242f 18 0d e5 10 1a                     MOVB B,X,DISP2
2434 b4 10 18                           ANDA BCD2 ;se extrae el nibble mas significativo de BCD1.
2437 81 b0                              CMPA #$B0
2439 27 0b                              BEQ DISP1_OFF ;cuando el nibble mas significativo es $F se debe apagar el DISP1
243b 44                                 LSRA
243c 44                                 LSRA
243d 44                                 LSRA
243e 44                                 LSRA ;se traslada el nibble mas significativo a la parte baja del byte.
243f 18 0d e4 10 19                     MOVB A,X,DISP1
2444 20 11                              BRA FIN_BCD_7SEG
2446                    DISP1_OFF:
2446 18 0b 00 10 19                     MOVB #$00,DISP1
244b 20 0a                              BRA FIN_BCD_7SEG
                        
244d                    NO_BCD2:
244d 18 0b 00 10 19                     MOVB #$00,DISP1
2452 18 0b 00 10 1a                     MOVB #$00,DISP2
2457                    FIN_BCD_7SEG:
2457 3d                         	RTS
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina de servicio a interrupcion RTI: Esta subrutina descuenta contadores
                        ;     siempre y cuando no sean cero. Los ticks del RTI duran 1.024 ms, por lo
                        ;     que si se cargan variables con X valor se pueden contar aproximadamente
                        ;     X milisegundos. Cont_Reb tiene un valor maximo de 10; se utiliza para
                        ;     suprimir rebotes contando ~10ms. TIMER_CUENTA tiene un valor maximo de
                        ;     VMAX (245), y cuenta ~250ms; se utiliza para simular la cuenta de tornillos
                        ;     a 4 Hz.
                        ;------------------------------------------------------------------------------
2458                    RTI_ISR:
2458 4c 37 80                           BSET CRGFLG %10000000 ;se limpia la bandera de interrupcion RTI
245b f7 10 04                           TST Cont_Reb ;se ve si el contador de rebotes llego a 0
245e 27 03                              BEQ CHECK_TIMER;si no, se pasa a revisar el timer
2460 73 10 04                           DEC Cont_Reb
2463                    CHECK_TIMER:
2463 f7 10 0c                           TST TIMER_CUENTA ;se revisa si el timer ha llegado a 0
2466 27 03                              BEQ FIN_RTI
2468 73 10 0c                           DEC TIMER_CUENTA
246b                    FIN_RTI:
246b 0b                                 RTI
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina de servicio a interrupcion keywakeup en puerto H: revisa las 4
                        ;     posibles fuentes de interrupcion PH0, PH1, PH2, PH3. La primer borra el
                        ;     valor de CUENTA, la segunda borra el valor de AcmPQ, la tercera disminuye
                        ;     el brillo en un 5%, la cuarta aumenta el brillo en un 5%.
                        ;------------------------------------------------------------------------------
246c                    PTH_ISR:
246c 1e 10 00 08 20                     BRSET Banderas %00001000 NO_RUN ;las interrupciones PTH
2471 1f 02 67 01 0f                     BRCLR PIFH $01 PTH1 ;si es 1, se revisa por la siguiente fuente de interrupcion
2476 1c 02 67 01                        BSET PIFH $01 ;se apaga la bandera de la fuente de interrupcion
247a 4c 38 80                           BSET CRGINT %10000000 ;Habilita interrupciones de RTI
247d 18 0b 00 00 08                     MOVB #$00,PORTE ;se apaga el relay
2482 79 10 09                           CLR CUENTA ;se reinicia la cuenta
2485                    PTH1:
2485 1f 02 67 02 07                     BRCLR PIFH $02 NO_RUN ;si es 1, se revisa por la siguiente fuente de interrupcion
248a 1c 02 67 02                        BSET PIFH $02 ;se apaga la bandera de la fuente de interrupcion
248e 79 10 0a                           CLR AcmPQ ;se limpia el acumulador
2491                    NO_RUN:
2491 b6 10 0e           		LDAA BRILLO
2494 c6 05                              LDAB #5
2496 1f 02 67 04 0c                     BRCLR PIFH $04 PTH3 ;si es 1, se revisa por la siguiente fuente de interrupcion
249b 1c 02 67 04                        BSET PIFH $04 ;se apaga la bandera de la fuente de interrupcion
249f 97                                 TSTA
24a0 27 05                              BEQ PTH3 ;si BRILLO es 0, no se le puede restar 5 y se revisa por la siguiente interrupcion
24a2 18 16                              SBA
24a4 7a 10 0e                           STAA BRILLO ;se le resta 5 a BRILLO
24a7                    PTH3:
24a7 1f 02 67 08 0d                     BRCLR PIFH $08 FIN_PTH ;si es 1, se termina la subrutina
24ac 1c 02 67 08                        BSET PIFH $08 ;se apaga la bandera de la fuente de interrupcion
24b0 81 64                              CMPA #100
24b2 27 05                              BEQ FIN_PTH ;si BRILLO es 100, no se le puede sumar 5 y se termina la rutina
24b4 18 06                              ABA
24b6 7a 10 0e                           STAA BRILLO ;se le suma 5 a BRILLO
24b9                    FIN_PTH:
24b9 0b                                 RTI ;termina la rutina de atencion a interrupciones
                        
                        ;------------------------------------------------------------------------------
                        ;   Subrutina de servicio a interrupcion por output compare en el canal 4:
                        ;     Descuenta Cont_Delay, refresca cada 100 ms (5000ticks) los valores de
                        ;     DISP1-DISP4, multiplexa el bus del puerto B para mostrar informacion en
                        ;     los displays de 7 segmentos y los LEDS, y todo con un ciclo de trabajo
                        ;     variable que depende de BRILLO.
                        ;------------------------------------------------------------------------------
24ba                    OC4_ISR:
24ba f7 10 1f                           TST Cont_Delay
24bd 27 03                              BEQ REFRESH ;se descuenta el contador solo si no es cero
24bf 73 10 1f                           DEC Cont_Delay
24c2                    REFRESH:
24c2 fc 10 1d                           LDD CONT_7SEG ;por tratarse de un WORD se debe traer al registro D para restarle 1
24c5 83 00 01                           SUBD #1
24c8 7c 10 1d                           STD CONT_7SEG ;se guarda el nuevo valor, y esto a la vez afecta la bandera Z
24cb 26 0c                              BNE SELECT_DISP ;cuando CONT_7SEG=0 se refrescan los valores de los displays
24cd 18 03 13 88 10 1d                  MOVW #5000,CONT_7SEG ;se reinicia el contador de refrescamiento de la informacion
24d3 16 22 1e                           JSR CONV_BIN_BCD
24d6 16 23 e4                           JSR BCD_7SEG ;se refresca la informacion
24d9                    SELECT_DISP:
24d9 86 64                              LDAA #100
24db b1 10 10                           CMPA CONT_TICKS ;cuando CONT_TICKS=N se debe cambiar de digito
24de 26 10                              BNE MULTIPLEX ;si no es igual entonces no hay que cambiar de digito y se puede continuar
24e0 79 10 10                           CLR CONT_TICKS ;se reinicia el contador de ticks
24e3 72 10 0f                           INC CONT_DIG ;se pasa al siguiente digito
24e6 86 05                              LDAA #5
24e8 b1 10 0f                           CMPA CONT_DIG ;cuando CONT_DIG alcance 5 se debe volver a colocar en 0 para que sea circular
24eb 26 03                              BNE MULTIPLEX ;si no es 5 no hay que corregir nada y se puede continuar
24ed 79 10 0f                           CLR CONT_DIG
24f0                    MULTIPLEX:
24f0 86 64                              LDAA #100
24f2 b0 10 0e                           SUBA BRILLO
24f5 7a 10 11                           STAA DT
24f8 f7 10 10                           TST CONT_TICKS
24fb 26 5c                              BNE DUTY_CYCLE ;cuando CONT_TICKS=0 se debe habiliar algun Display. Si no, se puede pasar a comprobar el ciclo de trabajo
24fd 18 0b 02 02 68                     MOVB #$02,PTJ ;se deshabilitan los LEDS
2502 18 0b ff 02 58                     MOVB #$FF,PTP ;se deshabilitan displays de 7 segmentos
2507 b6 10 0f                           LDAA CONT_DIG ;se comparan todos los posibles valores para determinar cual display encender
250a 81 00                              CMPA #0
250c 27 19                              BEQ DIG0
250e 81 01                              CMPA #1
2510 27 22                              BEQ DIG1
2512 81 02                              CMPA #2
2514 27 2b                              BEQ DIG2
2516 81 03                              CMPA #3
2518 27 34                              BEQ DIG3
                                        ;Ningun Display se debe habilitar, entonces son los LEDS
251a 18 0b 00 02 68                     MOVB #$00,PTJ ;se habilitan los LEDS
251f 18 0c 10 0d 00 01                  MOVB LEDS,PORTB ;se coloca en puerto B el estado de los LEDS.
2525 20 32                              BRA DUTY_CYCLE ;se pasa a comprobar el ciclo de trabajo
2527                    DIG0:
2527 18 0b f7 02 58                     MOVB #$F7,PTP ;se habilita unicamente el display 4
252c 18 0c 10 1c 00 01                  MOVB DISP4,PORTB ;se coloca en el puerto B el valor del display 4
2532 20 25                              BRA DUTY_CYCLE
2534                    DIG1:
2534 18 0b fb 02 58                     MOVB #$FB,PTP ;se habilita unicamente el display 3
2539 18 0c 10 1b 00 01                  MOVB DISP3,PORTB ;se coloca en el puerto B el valor del display 3
253f 20 18                              BRA DUTY_CYCLE
2541                    DIG2:
2541 18 0b fd 02 58                     MOVB #$FD,PTP ;se habilita unicamente el display 2
2546 18 0c 10 1a 00 01                  MOVB DISP2,PORTB ;se coloca en el puerto B el valor del display 2
254c 20 0b                              BRA DUTY_CYCLE
254e                    DIG3:
254e 18 0b fe 02 58                     MOVB #$FE,PTP ;se habilita unicamente el display 1
2553 18 0c 10 19 00 01                  MOVB DISP1,PORTB ;se coloca en el puerto B el valor del display 1
2559                    DUTY_CYCLE:
2559 b6 10 10                           LDAA CONT_TICKS
255c b1 10 11                           CMPA DT
255f 26 0a                              BNE FIN_OC4
2561 18 0b ff 02 58                     MOVB #$FF,PTP ;se deshabilitan displays de 7 segmentos
2566 18 0b 02 02 68                     MOVB #$02,PTJ ;se deshabilitan los LEDS
256b                    FIN_OC4:
256b 72 10 10                           INC CONT_TICKS
256e 4c 4e 10                           BSET TFLG1 %00010000 ;se reinicia la bandera de interrupcion
2571 dc 44                              LDD TCNT ;se carga el valor actual de TCNT para reajustar el output compare
2573 c3 00 3c                           ADDD #60 ;60 cuentas equivalen 50kHz con prescalador=8
2576 5c 58                              STD TC4 ;se actualiza el nuevo valor a alcanzar.
2578 0b                                 RTI

Executed: Thu Feb 11 23:23:28 2021
Total cycles: 1574, Total bytes: 1494
Total errors: 0, Total warnings: 0
