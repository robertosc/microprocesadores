
as12, an absolute assembler for Motorola MCU's, version 1.2h

                        ;##############################################################################
                        ;                                 Tarea #4
                        ;   Fecha: 05 de Febrero de 2021
                        ;   Autor: Luis guillermo Ramirez y Roberto S�nchez
                        ;
                        ;   Este programa tiene como fin leer el teclado matricual que ccontiene la tarjeta
                        ;   Drago 12+, para ello se genera un flujo iterativo que est� reccoriendose
                        ;   en busca de que se presione una tecla. PPara ello se genera una subrutina que
                        ;   identifica si se presion� algo. El dato presionado se almacena en memoria y
                        ;   luego se mueve a un array de datos. Tambi�n tiene una interrupci�n de tiempo
                        ;   real y una por bot�n.
                        ;##############################################################################
                        
                        #include registers.inc
                        ; Memory maps and register equates
                        ; Choose one of DBUG12MAP (normal operation under DBUG12)
                        ;               EEPROMMAP  (DBUG12 in EEPROM mode)
                        ;               FLASHMAP   (Program loaded into Flash ROM)
0000                    DBUG12MAP equ 0        ; Memory mode is DBUG12MAP
                        ; EEPROMMAP equ 0         ; Memory mode is EEPROMMAP
                        #ifdef DBUG12MAP
0000                    REGBASE        equ        $0        ; register base
1000                    DATASTART equ        $1000        ; Start of data memory
2000                    DATAEND  equ        $2000        ; Stack pointer initial value (end of data RAM area)
2000                    PRSTART equ        $2000        ; Start of program memory (might be ROM)
3bff                    PREND        equ        $3BFF        ; End of program memory
                        
                        ; Functions in D-Bug12
ee84                    Getchar        equ        $EE84        ; Implemented in emulator
ee86                    Putchar equ        $EE86   ; Implemented in emulator
ee88                    Printf  equ     $EE88
ee8a                    GetCmdLine equ  $EE8A   ; FAR call
ee8e                    Sscanhex equ        $EE8E   ; FAR call
ee92                    Isxdigit equ    $EE92
ee94                    Toupper equ     $EE94
ee96                    Isalpha equ     $EE96
ee98                    Strlen  equ     $EE98
ee9a                    Strcpy  equ     $EE9A
ee9c                    Out2hex equ     $EE9C   ; FAR call
eea0                    Out4hex equ     $EEA0   ; FAR call
eea4                    SetUserVector equ $EEA4 ; No longer used
eea6                    WriteEEByte equ $EEA6   ; FAR call
eeaa                    EraseEE equ     $EEAA   ; FAR call
eeae                    ReadMem equ     $EEAE   ; FAR call
eeb2                    WriteMem equ    $EEB2   ; FAR call
                        
3e00                    VECTORTABLE equ $3E00        ; Vectors go here SHOULD ALSO INITIALIZE AT RUNTIME
0000                    STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
0000                    INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef EEPROMMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $3E00        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $400        ; Start of program memory
                        PREND        equ        $FFF        ; End of program memory
                        
                        VECTORTABLE equ $3E00        ; Vectors go here -- MUST BE INITIALIZED AT RUNTIME
                        INITIALIZEVECTORS equ 0        ; Initialize vectors at runtime
                        #endif
                        
                        #ifdef FLASHMAP
                        REGBASE        equ        $0        ; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ        $1000        ; Start of data memory
                        DATAEND  equ        $4000        ; Stack pointer initial value (end of data RAM area)
                        PRSTART equ        $8000        ; Start of program memory
                        ; Note -- there are problems using the current free assemblers with paged memory
                        ; Best bet is to use logical addresses $8000 up only, set page register to 3E,
                        ; Change S1 records for $8000-BFFF to S2 records for page 3E and S1 records for $C000-$EFFF to
                        ; page 3F. Program startup vector goes in EFFE, and needs to be iin page 3F so PPAGE can be changed. 
                        PREND        equ        $EF7F        ; End of program memory
                        
                        VECTORTABLE equ $EF80        ; Vectors go here -- MUST BE INITIALIZED STATICALLY
                        STATICVECTORS equ 0        ; Define vectors statically (in "ROM")
                        #endif
                        
                        
1000                    RAMSTART equ        DATASTART ; For compatibility
2000                    RAMEND equ        DATAEND   
                        
3e00                    UserRsrv0x80 equ (0*2)+VECTORTABLE
3e02                    UserRsrv0x82 equ (1*2)+VECTORTABLE
3e04                    UserRsrv0x84 equ (2*2)+VECTORTABLE
3e06                    UserRsrv0x86 equ (3*2)+VECTORTABLE
3e08                    UserRsrv0x88 equ (4*2)+VECTORTABLE
3e0a                    UserRsrv0x8a equ (5*2)+VECTORTABLE
3e0c                    UserPWMShDn equ (6*2)+VECTORTABLE
3e0e                    UserPortP equ (7*2)+VECTORTABLE
3e10                    UserMSCAN4Tx equ (8*2)+VECTORTABLE
3e12                    UserMSCAN4Rx equ (9*2)+VECTORTABLE
3e14                    UserMSCAN4Errs equ (10*2)+VECTORTABLE
3e16                    UserMSCAN4Wake equ (11*2)+VECTORTABLE
3e18                    UserMSCAN3Tx equ (12*2)+VECTORTABLE
3e1a                    UserMSCAN3Rx equ (13*2)+VECTORTABLE
3e1c                    UserMSCAN3Errs equ (14*2)+VECTORTABLE
3e1e                    UserMSCAN3Wake equ (15*2)+VECTORTABLE
3e20                    UserMSCAN2Tx equ (16*2)+VECTORTABLE
3e22                    UserMSCAN2Rx equ (17*2)+VECTORTABLE
3e24                    UserMSCAN2Errs equ (18*2)+VECTORTABLE
3e26                    UserMSCAN2Wake equ (19*2)+VECTORTABLE
3e28                    UserMSCAN1Tx equ (20*2)+VECTORTABLE
3e2a                    UserMSCAN1Rx equ (21*2)+VECTORTABLE
3e2c                    UserMSCAN1Errs equ (22*2)+VECTORTABLE
3e2e                    UserMSCAN1Wake equ (23*2)+VECTORTABLE
3e30                    UserMSCAN0Tx equ (24*2)+VECTORTABLE
3e32                    UserMSCAN0Rx equ (25*2)+VECTORTABLE
3e34                    UserMSCAN0Errs equ (26*2)+VECTORTABLE
3e36                    UserMSCAN0Wake equ (27*2)+VECTORTABLE
3e38                    UserFlash equ (28*2)+VECTORTABLE
3e3a                    UserEEPROM equ (29*2)+VECTORTABLE
3e3c                    UserSPI2 equ (30*2)+VECTORTABLE
3e3e                    UserSPI1 equ (31*2)+VECTORTABLE
3e40                    UserIIC equ (32*2)+VECTORTABLE
3e42                    UserDLC equ (33*2)+VECTORTABLE
3e44                    UserSCME equ (34*2)+VECTORTABLE
3e46                    UserCRG equ (35*2)+VECTORTABLE
3e48                    UserPAccBOv equ (36*2)+VECTORTABLE
3e4a                    UserModDwnCtr equ (37*2)+VECTORTABLE
3e4c                    UserPortH equ (38*2)+VECTORTABLE
3e4e                    UserPortJ equ (39*2)+VECTORTABLE
3e50                    UserAtoD1 equ (40*2)+VECTORTABLE
3e52                    UserAtoD0 equ (41*2)+VECTORTABLE
3e54                    UserSCI1 equ (42*2)+VECTORTABLE
3e56                    UserSCI0 equ (43*2)+VECTORTABLE
3e58                    UserSPI0 equ (44*2)+VECTORTABLE
3e5a                    UserPAccEdge equ (45*2)+VECTORTABLE
3e5c                    UserPAccOvf equ (46*2)+VECTORTABLE
3e5e                    UserTimerOvf equ (47*2)+VECTORTABLE
3e60                    UserTimerCh7 equ (48*2)+VECTORTABLE
3e62                    UserTimerCh6 equ (49*2)+VECTORTABLE
3e64                    UserTimerCh5 equ (50*2)+VECTORTABLE
3e66                    UserTimerCh4 equ (51*2)+VECTORTABLE
3e68                    UserTimerCh3 equ (52*2)+VECTORTABLE
3e6a                    UserTimerCh2 equ (53*2)+VECTORTABLE
3e6c                    UserTimerCh1 equ (54*2)+VECTORTABLE
3e6e                    UserTimerCh0 equ (55*2)+VECTORTABLE
3e70                    UserRTI equ (56*2)+VECTORTABLE
3e72                    UserIRQ equ (57*2)+VECTORTABLE
3e74                    UserXIRQ equ (58*2)+VECTORTABLE
3e76                    UserSWI equ (59*2)+VECTORTABLE
3e78                    UserTrap equ (60*2)+VECTORTABLE
                        
                        
                        *
                        *
                        *  HC12 i/o register locations (9s12dp256)
                        *
                        *
0000                    PORTA:          equ REGBASE+0   ;port a = address lines a8 - a15
0001                    PORTB:          equ REGBASE+1   ;port b = address lines a0 - a7
0002                    DDRA:           equ REGBASE+2   ;port a direction register
0003                    DDRB:           equ REGBASE+3   ;port b direction register
                        
0008                    PORTE:          equ REGBASE+8   ;port e = mode,irq and control signals
0009                    DDRE:           equ REGBASE+9   ;port e direction register
000a                    PEAR:           equ REGBASE+$a  ;port e assignments
000b                    MODE:           equ REGBASE+$b  ;mode register
000c                    PUCR:           equ REGBASE+$c  ;port pull-up control register
000d                    RDRIV:          equ REGBASE+$d  ;port reduced drive control register
000e                    EBICTL:                equ REGBASE+$e  ;e stretch control
                        
0010                    INITRM:         equ REGBASE+$10 ;ram location register
0011                    INITRG:         equ REGBASE+$11 ;register location register
0012                    INITEE:         equ REGBASE+$12 ;eeprom location register
0013                    MISC:           equ REGBASE+$13 ;miscellaneous mapping control
0014                    MTST0:          equ REGBASE+$14 ; reserved
0015                    ITCR:           equ REGBASE+$15 ;interrupt test control register
0016                    ITEST:          equ REGBASE+$16 ;interrupt test register
0017                    MTST1:          equ REGBASE+$17 ; reserved
                        
001a                    PARTIDH:        equ REGBASE+$1a ;part id high
001b                    PARTIDL:        equ REGBASE+$1b ;part id low
001c                    MEMSIZ0:        equ REGBASE+$1c ;memory size
001d                    MEMSIZ1:        equ REGBASE+$1d ;memory size
001e                    IRQCR:          equ REGBASE+$1e ;interrupt control register
001e                    INTCR:          equ REGBASE+$1e ;interrupt control register (old name)
001f                    HPRIO:          equ REGBASE+$1f ;high priority reg
                        
0028                    BKPCT0:         equ REGBASE+$28 ;break control register
0029                    BKPCT1:         equ REGBASE+$29 ;break control register
002a                    BKP0X:          equ REGBASE+$2a ; break 0 index register
002b                    BKP0H:          equ REGBASE+$2b ; break 0 pointer high
002c                    BRP0L:          equ REGBASE+$2c ; break 0 pointer low
002d                    BKP1X:          equ REGBASE+$2d ; break 1 index register
002e                    BKP1H:          equ REGBASE+$2e ; break 1 pointer high
002f                    BRP1L:          equ REGBASE+$2f ; break 1 pointer low
0030                    PPAGE:                equ REGBASE+$30 ;program page register
                        
0032                    PORTK:                equ REGBASE+$32 ;port k data
0033                    DDRK:                equ REGBASE+$33 ;port k direction
                        
0034                    SYNR:           equ REGBASE+$34 ; synthesizer / multiplier register
0035                    REFDV:          equ REGBASE+$35 ; reference divider register
0036                    CTFLG:          equ REGBASE+$36 ; reserved
0037                    CRGFLG:         equ REGBASE+$37 ; pll flags register
0038                    CRGINT:         equ REGBASE+$38 ; pll interrupt register
0039                    CLKSEL:         equ REGBASE+$39 ; clock select register
003a                    PLLCTL:         equ REGBASE+$3a ; pll control register
003b                    RTICTL:         equ REGBASE+$3b ;real time interrupt control
003c                    COPCTL:         equ REGBASE+$3c ;watchdog control
003d                    FORBYP:         equ REGBASE+$3d ;
003e                    CTCTL:          equ REGBASE+$3e ;
003f                    ARMCOP:         equ REGBASE+$3f ;cop reset register
                        
0040                    TIOS:           equ REGBASE+$40 ;timer input/output select
0041                    CFORC:          equ REGBASE+$41 ;timer compare force
0042                    OC7M:           equ REGBASE+$42 ;timer output compare 7 mask
0043                    OC7D:           equ REGBASE+$43 ;timer output compare 7 data
0044                    TCNT:           equ REGBASE+$44 ;timer counter register hi
                        *TCNT:          equ REGBASE+$45 ;timer counter register lo
0046                    TSCR:           equ REGBASE+$46 ;timer system control register (Old Name)
0046                    TSCR1:          equ REGBASE+$46 ;timer system control register
0047                    TTOV:           equ REGBASE+$47 ;reserved
0048                    TCTL1:          equ REGBASE+$48 ;timer control register 1
0049                    TCTL2:          equ REGBASE+$49 ;timer control register 2
004a                    TCTL3:          equ REGBASE+$4a ;timer control register 3
004b                    TCTL4:          equ REGBASE+$4b ;timer control register 4
004c                    TMSK1:          equ REGBASE+$4c ;timer interrupt mask 1 (Old Name)
004c                    TIE:            equ REGBASE+$4c ;timer interrupt mask 1
004d                    TMSK2:          equ REGBASE+$4d ;timer interrupt mask 2 (Old Name)
004d                    TSCR2:          equ REGBASE+$4d ;timer interrupt mask 2
004e                    TFLG1:          equ REGBASE+$4e ;timer flags 1
004f                    TFLG2:          equ REGBASE+$4f ;timer flags 2
0050                    TC0:            equ REGBASE+$50 ;timer capture/compare register 0
0052                    TC1:            equ REGBASE+$52 ;timer capture/compare register 1
0054                    TC2:            equ REGBASE+$54 ;timer capture/compare register 2
0056                    TC3:            equ REGBASE+$56 ;timer capture/compare register 3
0058                    TC4:            equ REGBASE+$58 ;timer capture/compare register 4
005a                    TC5:            equ REGBASE+$5a ;timer capture/compare register 5
005c                    TC6:            equ REGBASE+$5c ;timer capture/compare register 6
005e                    TC7:            equ REGBASE+$5e ;timer capture/compare register 7
0060                    PACTL:          equ REGBASE+$60 ;pulse accumulator controls
0061                    PAFLG:          equ REGBASE+$61 ;pulse accumulator flags
0062                    PACN3:          equ REGBASE+$62 ;pulse accumulator counter 3
0063                    PACN2:          equ REGBASE+$63 ;pulse accumulator counter 2
0064                    PACN1:          equ REGBASE+$64 ;pulse accumulator counter 1
0065                    PACN0:          equ REGBASE+$65 ;pulse accumulator counter 0
0066                    MCCTL:          equ REGBASE+$66 ;modulus down conunter control
0067                    MCFLG:          equ REGBASE+$67 ;down counter flags
0068                    ICPAR:          equ REGBASE+$68 ;input pulse accumulator control
0069                    DLYCT:          equ REGBASE+$69 ;delay count to down counter
006a                    ICOVW:          equ REGBASE+$6a ;input control overwrite register
006b                    ICSYS:          equ REGBASE+$6b ;input control system control
                        
006d                    TIMTST:         equ REGBASE+$6d ;timer test register
                        
0070                    PBCTL:          equ REGBASE+$70 ; pulse accumulator b control
0071                    PBFLG:          equ REGBASE+$71 ; pulse accumulator b flags
0072                    PA3H:           equ REGBASE+$72 ; pulse accumulator holding register 3
0073                    PA2H:           equ REGBASE+$73 ; pulse accumulator holding register 2
0074                    PA1H:           equ REGBASE+$74 ; pulse accumulator holding register 1
0075                    PA0H:           equ REGBASE+$75 ; pulse accumulator holding register 0
0076                    MCCNT:          equ REGBASE+$76 ; modulus down counter register
                        *MCCNTL:        equ REGBASE+$77 ; low byte
0078                    TCOH:           equ REGBASE+$78 ; capture 0 holding register
007a                    TC1H:           equ REGBASE+$7a ; capture 1 holding register
007c                    TC2H:           equ REGBASE+$7c ; capture 2 holding register
007e                    TC3H:           equ REGBASE+$7e ; capture 3 holding register
                        
0080                    ATD0CTL0:       equ REGBASE+$80 ;adc control 0 (reserved)
0081                    ATD0CTL1:       equ REGBASE+$81 ;adc control 1 (reserved)
0082                    ATD0CTL2:       equ REGBASE+$82 ;adc control 2
0083                    ATD0CTL3:       equ REGBASE+$83 ;adc control 3
0084                    ATD0CTL4:       equ REGBASE+$84 ;adc control 4
0085                    ATD0CTL5:       equ REGBASE+$85 ;adc control 5
0086                    ATD0STAT:       equ REGBASE+$86 ;adc status register hi
0086                    ATD0STAT0:      equ REGBASE+$86 ;adc status register hi
008b                    ATD0STAT1:      equ REGBASE+$8b ;adc status register lo
0088                    ATD0TEST:       equ REGBASE+$88 ;adc test (reserved)
                        *atd0test       equ REGBASE+$89 ;
                        
008d                    ATD0DIEN:        equ REGBASE+$8d ;
                        
008f                    PORTAD:         equ REGBASE+$8f ;port adc = input only
0090                    ADR00H:         equ REGBASE+$90 ;adc result 0 register
0092                    ADR01H:         equ REGBASE+$92 ;adc result 1 register
0094                    ADR02H:         equ REGBASE+$94 ;adc result 2 register
0096                    ADR03H:         equ REGBASE+$96 ;adc result 3 register
0098                    ADR04H:         equ REGBASE+$98 ;adc result 4 register
009a                    ADR05H:         equ REGBASE+$9a ;adc result 5 register
009c                    ADR06H:         equ REGBASE+$9c ;adc result 6 register
009e                    ADR07H:         equ REGBASE+$9e ;adc result 7 register
                        
00a0                    PWME:                equ REGBASE+$a0 ;pwm enable
00a1                    PWMPOL:         equ REGBASE+$a1 ;pwm polarity
00a2                    PWMCLK:         equ REGBASE+$a2 ;pwm clock select register
00a3                    PWMPRCLK:       equ REGBASE+$a3 ;pwm prescale clock select register
00a4                    PWMCAE:         equ REGBASE+$a4 ;pwm center align select register
00a5                    PWMCTL:         equ REGBASE+$a5 ;pwm control register
00a6                    PWMTST:         equ REGBASE+$a6 ;reserved
00a7                    PWMPRSC:        equ REGBASE+$a7 ;reserved
00a8                    PWMSCLA:        equ REGBASE+$a8 ;pwm scale a
00a9                    PWMSCLB:        equ REGBASE+$a9 ;pwm scale b
00aa                    PWMSCNTA:       equ REGBASE+$aa ;reserved
00ab                    PWMSCNTB:       equ REGBASE+$ab ;reserved
00ac                    PWMCNT0:        equ REGBASE+$ac ;pwm channel 0 counter
00ad                    PWMCNT1:        equ REGBASE+$ad ;pwm channel 1 counter
00ae                    PWMCNT2:        equ REGBASE+$ae ;pwm channel 2 counter
00af                    PWMCNT3:        equ REGBASE+$af ;pwm channel 3 counter
00b0                    PWMCNT4:        equ REGBASE+$b0 ;pwm channel 4 counter
00b1                    PWMCNT5:        equ REGBASE+$b1 ;pwm channel 5 counter
00b2                    PWMCNT6:        equ REGBASE+$b2 ;pwm channel 6 counter
00b3                    PWMCNT7:        equ REGBASE+$b3 ;pwm channel 7 counter
00b4                    PWMPER0:        equ REGBASE+$b4 ;pwm channel 0 period
00b5                    PWMPER1:        equ REGBASE+$b5 ;pwm channel 1 period
00b6                    PWMPER2:        equ REGBASE+$b6 ;pwm channel 2 period
00b7                    PWMPER3:        equ REGBASE+$b7 ;pwm channel 3 period
00b8                    PWMPER4:        equ REGBASE+$b8 ;pwm channel 4 period
00b9                    PWMPER5:        equ REGBASE+$b9 ;pwm channel 5 period
00ba                    PWMPER6:        equ REGBASE+$ba ;pwm channel 6 period
00bb                    PWMPER7:        equ REGBASE+$bb ;pwm channel 7 period
00bc                    PWMDTY0:        equ REGBASE+$bc ;pwm channel 0 duty cycle
00bd                    PWMDTY1:        equ REGBASE+$bd ;pwm channel 1 duty cycle
00be                    PWMDTY2:        equ REGBASE+$be ;pwm channel 2 duty cycle
00bf                    PWMDTY3:        equ REGBASE+$bf ;pwm channel 3 duty cycle
00c0                    PWMDTY4:        equ REGBASE+$c0 ;pwm channel 4 duty cycle
00c1                    PWMDTY5:        equ REGBASE+$c1 ;pwm channel 5 duty cycle
00c2                    PWMDTY6:        equ REGBASE+$c2 ;pwm channel 6 duty cycle
00c3                    PWMDTY7:        equ REGBASE+$c3 ;pwm channel 7 duty cycle
00c4                    PWMSDN:         equ REGBASE+$c4 ;pwm shutdown register
                        
00c8                    SC0BDH:         equ REGBASE+$c8 ;sci 0 baud reg hi byte
00c9                    SC0BDL:         equ REGBASE+$c9 ;sci 0 baud reg lo byte
00ca                    SC0CR1:         equ REGBASE+$ca ;sci 0 control1 reg
00cb                    SC0CR2:         equ REGBASE+$cb ;sci 0 control2 reg
00cc                    SC0SR1:         equ REGBASE+$cc ;sci 0 status reg 1
00cd                    SC0SR2:         equ REGBASE+$cd ;sci 0 status reg 2
00ce                    SC0DRH:         equ REGBASE+$ce ;sci 0 data reg hi
00cf                    SC0DRL:         equ REGBASE+$cf ;sci 0 data reg lo
                        
00d0                    SC1BDH:         equ REGBASE+$d0 ;sci 1 baud reg hi byte
00d1                    SC1BDL:         equ REGBASE+$d1 ;sci 1 baud reg lo byte
00d2                    SC1CR1:         equ REGBASE+$d2 ;sci 1 control1 reg
00d3                    SC1CR2:         equ REGBASE+$d3 ;sci 1 control2 reg
00d4                    SC1SR1:         equ REGBASE+$d4 ;sci 1 status reg 1
00d5                    SC1SR2:         equ REGBASE+$d5 ;sci 1 status reg 2
00d6                    SC1DRH:         equ REGBASE+$d6 ;sci 1 data reg hi
00d7                    SC1DRL:         equ REGBASE+$d7 ;sci 1 data reg lo
                        
00d8                    SPI0CR1:        equ REGBASE+$d8 ;spi 0 control1 reg
00d9                    SPI0CR2:        equ REGBASE+$d9 ;spi 0 control2 reg
00da                    SPI0BR:         equ REGBASE+$da ;spi 0 baud reg
00db                    SPI0SR:         equ REGBASE+$db ;spi 0 status reg hi
00dd                    SP0DR:          equ REGBASE+$dd ;spi 0 data reg  FOR COMPATIBILITY
00dd                    SPI0DR:          equ REGBASE+$dd ;spi 0 data reg
                        
00e0                    IBAD:                equ REGBASE+$e0 ;i2c bus address register
00e1                    IBFD:                equ REGBASE+$e1 ;i2c bus frequency divider
00e2                    IBCR:                equ REGBASE+$e2 ;i2c bus control register
00e3                    IBSR:                equ REGBASE+$e3 ;i2c bus status register
00e4                    IBDR:                equ REGBASE+$e4 ;i2c bus message data register
                        
00e8                    DLCBCR1:        equ REGBASE+$e8 ;bdlc control regsiter 1
00e9                    DLCBSVR:        equ REGBASE+$e9 ;bdlc state vector register
00ea                    DLCBCR2:        equ REGBASE+$ea ;bdlc control register 2
00eb                    DLCBDR:                equ REGBASE+$eb ;bdlc data register
00ec                    DLCBARD:        equ REGBASE+$ec ;bdlc analog delay register
00ed                    DLCBRSR:        equ REGBASE+$ed ;bdlc rate select register
00ee                    DLCSCR:                equ REGBASE+$ee ;bdlc control register
00ef                    DLCBSTAT:        equ REGBASE+$ef ;bdlc status register
                        
00f0                    SPI1CR1:        equ REGBASE+$f0 ;spi 1 control1 reg
00f1                    SPI1CR2:        equ REGBASE+$f1 ;spi 1 control2 reg
00f2                    SPI1BR:         equ REGBASE+$f2 ;spi 1 baud reg
00f3                    SPI1SR:         equ REGBASE+$f3 ;spi 1 status reg hi
00f5                    SPI1DR:          equ REGBASE+$f5 ;spi 1 data reg
00f5                    SP1DR:          equ REGBASE+$f5 ;spi 1 data reg   FOR COMPATIBILITY
                        
00f8                    SPI2CR1:        equ REGBASE+$f8 ;spi 2 control1 reg
00f9                    SPI2CR2:        equ REGBASE+$f9 ;spi 2 control2 reg
00fa                    SPI2BR:         equ REGBASE+$fa ;spi 2 baud reg
00fb                    SPI2SR:         equ REGBASE+$fb ;spi 2 status reg hi
00fd                    SPI2DR:         equ REGBASE+$fd ;spi 2 data reg
00fd                    SP2DR:          equ REGBASE+$fd ;spi 2 data reg   FOR COMPATIBILITY
                        
0100                    FCLKDIV:        equ REGBASE+$100 ;flash clock divider
0101                    FSEC:                equ REGBASE+$101 ;flash security register
                        
0103                    FCNFG:                equ REGBASE+$103 ;flash configuration register
0104                    FPROT:                equ REGBASE+$104 ;flash protection register
0105                    FSTAT:                equ REGBASE+$105 ;flash status register
0106                    FCMD:                equ REGBASE+$106 ;flash command register
                        
0110                    ECLKDIV:        equ REGBASE+$110 ;eeprom clock divider
                        
0113                    ECNFG:                equ REGBASE+$113 ;eeprom configuration register
0114                    EPROT:                equ REGBASE+$114 ;eeprom protection register
0115                    ESTAT:                equ REGBASE+$115 ;eeprom status register
0116                    ECMD:                equ REGBASE+$116 ;eeprom command register
                        
0120                    ATD1CTL0:       equ REGBASE+$120 ;adc1 control 0 (reserved)
0121                    ATD1CTL1:       equ REGBASE+$121 ;adc1 control 1 (reserved)
0122                    ATD1CTL2:       equ REGBASE+$122 ;adc1 control 2
0123                    ATD1CTL3:       equ REGBASE+$123 ;adc1 control 3
0124                    ATD1CTL4:       equ REGBASE+$124 ;adc1 control 4
0125                    ATD1CTL5:       equ REGBASE+$125 ;adc1 control 5
0126                    ATD1STAT0:      equ REGBASE+$126 ;adc1 status register hi
012b                    ATD1STAT1:      equ REGBASE+$12b ;adc1 status register lo
0128                    ATD1TEST:       equ REGBASE+$128 ;adc1 test (reserved)
                        *atd1test       equ REGBASE+$129 ;
                        
012d                    ATDDIEN:        equ REGBASE+$12d ;adc1 input enable register
                        
012f                    PORTAD1:        equ REGBASE+$12f ;port adc1 = input only
0130                    ADR10H:         equ REGBASE+$130 ;adc1 result 0 register
0132                    ADR11H:         equ REGBASE+$132 ;adc1 result 1 register
0134                    ADR12H:         equ REGBASE+$134 ;adc1 result 2 register
0136                    ADR13H:         equ REGBASE+$136 ;adc1 result 3 register
0138                    ADR14H:         equ REGBASE+$138 ;adc1 result 4 register
013a                    ADR15H:         equ REGBASE+$13a ;adc1 result 5 register
013c                    ADR16H:         equ REGBASE+$13c ;adc1 result 6 register
013e                    ADR17H:         equ REGBASE+$13e ;adc1 result 7 register
                        
0140                    CAN0CTL0:        equ REGBASE+$140 ;can0 control register 0
0141                    CAN0CTL1:        equ REGBASE+$141 ;can0 control register 1
0142                    CAN0BTR0:        equ REGBASE+$142 ;can0 bus timing register 0
0143                    CAN0BTR1:        equ REGBASE+$143 ;can0 bus timing register 1
0144                    CAN0RFLG:        equ REGBASE+$144 ;can0 receiver flags
0145                    CAN0RIER:        equ REGBASE+$145 ;can0 receiver interrupt enables
0146                    CAN0TFLG:        equ REGBASE+$146 ;can0 transmit flags
0147                    CAN0TIER:        equ REGBASE+$147 ;can0 transmit interrupt enables
0148                    CAN0TARQ:        equ REGBASE+$148 ;can0 transmit message abort control
0149                    CAN0TAAK:        equ REGBASE+$149 ;can0 transmit message abort status
014a                    CAN0TBEL:        equ REGBASE+$14a ;can0 transmit buffer select
014b                    CAN0IDAC:        equ REGBASE+$14b ;can0 identfier acceptance control
                        
014e                    CAN0RERR:        equ REGBASE+$14e ;can0 receive error counter
014f                    CAN0TERR:        equ REGBASE+$14f ;can0 transmit error counter
0150                    CAN0IDA0:        equ REGBASE+$150 ;can0 identifier acceptance register 0
0151                    CAN0IDA1:        equ REGBASE+$151 ;can0 identifier acceptance register 1
0152                    CAN0IDA2:        equ REGBASE+$152 ;can0 identifier acceptance register 2
0153                    CAN0IDA3:        equ REGBASE+$153 ;can0 identifier acceptance register 3
0154                    CAN0IDM0:        equ REGBASE+$154 ;can0 identifier mask register 0
0155                    CAN0IDM1:        equ REGBASE+$155 ;can0 identifier mask register 1
0156                    CAN0IDM2:        equ REGBASE+$156 ;can0 identifier mask register 2
0157                    CAN0IDM3:        equ REGBASE+$157 ;can0 identifier mask register 3
0158                    CAN0IDA4:        equ REGBASE+$158 ;can0 identifier acceptance register 4
0159                    CAN0IDA5:        equ REGBASE+$159 ;can0 identifier acceptance register 5
015a                    CAN0IDA6:        equ REGBASE+$15a ;can0 identifier acceptance register 6
015b                    CAN0IDA7:        equ REGBASE+$15b ;can0 identifier acceptance register 7
015c                    CAN0IDM4:        equ REGBASE+$15c ;can0 identifier mask register 4
015d                    CAN0IDM5:        equ REGBASE+$15d ;can0 identifier mask register 5
015e                    CAN0IDM6:        equ REGBASE+$15e ;can0 identifier mask register 6
015f                    CAN0IDM7:        equ REGBASE+$15f ;can0 identifier mask register 7
0160                    CAN0RXFG:        equ REGBASE+$160 ;can0 rx foreground buffer thru +$16f
0170                    CAN0TXFG:        equ REGBASE+$170 ;can0 tx foreground buffer thru +$17f
                        
0180                    CAN1CTL0:        equ REGBASE+$180 ;can1 control register 0
0181                    CAN1CTL1:        equ REGBASE+$181 ;can1 control register 1
0182                    CAN1BTR0:        equ REGBASE+$182 ;can1 bus timing register 0
0183                    CAN1BTR1:        equ REGBASE+$183 ;can1 bus timing register 1
0184                    CAN1RFLG:        equ REGBASE+$184 ;can1 receiver flags
0185                    CAN1RIER:        equ REGBASE+$185 ;can1 receiver interrupt enables
0186                    CAN1TFLG:        equ REGBASE+$186 ;can1 transmit flags
0187                    CAN1TIER:        equ REGBASE+$187 ;can1 transmit interrupt enables
0188                    CAN1TARQ:        equ REGBASE+$188 ;can1 transmit message abort control
0189                    CAN1TAAK:        equ REGBASE+$189 ;can1 transmit message abort status
018a                    CAN1TBEL:        equ REGBASE+$18a ;can1 transmit buffer select
018b                    CAN1IDAC:        equ REGBASE+$18b ;can1 identfier acceptance control
                        
018e                    CAN1RERR:        equ REGBASE+$18e ;can1 receive error counter
018f                    CAN1TERR:        equ REGBASE+$18f ;can1 transmit error counter
0190                    CAN1IDA0:        equ REGBASE+$190 ;can1 identifier acceptance register 0
0191                    CAN1IDA1:        equ REGBASE+$191 ;can1 identifier acceptance register 1
0192                    CAN1IDA2:        equ REGBASE+$192 ;can1 identifier acceptance register 2
0193                    CAN1IDA3:        equ REGBASE+$193 ;can1 identifier acceptance register 3
0194                    CAN1IDM0:        equ REGBASE+$194 ;can1 identifier mask register 0
0195                    CAN1IDM1:        equ REGBASE+$195 ;can1 identifier mask register 1
0196                    CAN1IDM2:        equ REGBASE+$196 ;can1 identifier mask register 2
0197                    CAN1IDM3:        equ REGBASE+$197 ;can1 identifier mask register 3
0198                    CAN1IDA4:        equ REGBASE+$198 ;can1 identifier acceptance register 4
0199                    CAN1IDA5:        equ REGBASE+$199 ;can1 identifier acceptance register 5
019a                    CAN1IDA6:        equ REGBASE+$19a ;can1 identifier acceptance register 6
019b                    CAN1IDA7:        equ REGBASE+$19b ;can1 identifier acceptance register 7
019c                    CAN1IDM4:        equ REGBASE+$19c ;can1 identifier mask register 4
019d                    CAN1IDM5:        equ REGBASE+$19d ;can1 identifier mask register 5
019e                    CAN1IDM6:        equ REGBASE+$19e ;can1 identifier mask register 6
019f                    CAN1IDM7:        equ REGBASE+$19f ;can1 identifier mask register 7
01a0                    CAN1RXFG:        equ REGBASE+$1a0 ;can1 rx foreground buffer thru +$1af
01b0                    CAN1TXFG:        equ REGBASE+$1b0 ;can1 tx foreground buffer thru +$1bf
                        
01c0                    CAN2CTL0:        equ REGBASE+$1c0 ;can2 control register 0
01c1                    CAN2CTL1:        equ REGBASE+$1c1 ;can2 control register 1
01c2                    CAN2BTR0:        equ REGBASE+$1c2 ;can2 bus timing register 0
01c3                    CAN2BTR1:        equ REGBASE+$1c3 ;can2 bus timing register 1
01c4                    CAN2RFLG:        equ REGBASE+$1c4 ;can2 receiver flags
01c5                    CAN2RIER:        equ REGBASE+$1c5 ;can2 receiver interrupt enables
01c6                    CAN2TFLG:        equ REGBASE+$1c6 ;can2 transmit flags
01c7                    CAN2TIER:        equ REGBASE+$1c7 ;can2 transmit interrupt enables
01c8                    CAN2TARQ:        equ REGBASE+$1c8 ;can2 transmit message abort control
01c9                    CAN2TAAK:        equ REGBASE+$1c9 ;can2 transmit message abort status
01ca                    CAN2TBEL:        equ REGBASE+$1ca ;can2 transmit buffer select
01cb                    CAN2IDAC:        equ REGBASE+$1cb ;can2 identfier acceptance control
                        
01ce                    CAN2RERR:        equ REGBASE+$1ce ;can2 receive error counter
01cf                    CAN2TERR:        equ REGBASE+$1cf ;can2 transmit error counter
01d0                    CAN2IDA0:        equ REGBASE+$1d0 ;can2 identifier acceptance register 0
01d1                    CAN2IDA1:        equ REGBASE+$1d1 ;can2 identifier acceptance register 1
01d2                    CAN2IDA2:        equ REGBASE+$1d2 ;can2 identifier acceptance register 2
01d3                    CAN2IDA3:        equ REGBASE+$1d3 ;can2 identifier acceptance register 3
01d4                    CAN2IDM0:        equ REGBASE+$1d4 ;can2 identifier mask register 0
01d5                    CAN2IDM1:        equ REGBASE+$1d5 ;can2 identifier mask register 1
01d6                    CAN2IDM2:        equ REGBASE+$1d6 ;can2 identifier mask register 2
01d7                    CAN2IDM3:        equ REGBASE+$1d7 ;can2 identifier mask register 3
01d8                    CAN2IDA4:        equ REGBASE+$1d8 ;can2 identifier acceptance register 4
01d9                    CAN2IDA5:        equ REGBASE+$1d9 ;can2 identifier acceptance register 5
01da                    CAN2IDA6:        equ REGBASE+$1da ;can2 identifier acceptance register 6
01db                    CAN2IDA7:        equ REGBASE+$1db ;can2 identifier acceptance register 7
01dc                    CAN2IDM4:        equ REGBASE+$1dc ;can2 identifier mask register 4
01dd                    CAN2IDM5:        equ REGBASE+$1dd ;can2 identifier mask register 5
01de                    CAN2IDM6:        equ REGBASE+$1de ;can2 identifier mask register 6
01df                    CAN2IDM7:        equ REGBASE+$1df ;can2 identifier mask register 7
01e0                    CAN2RXFG:        equ REGBASE+$1e0 ;can2 rx foreground buffer thru +$1ef
01f0                    CAN2TXFG:        equ REGBASE+$1f0 ;can2 tx foreground buffer thru +$1ff
                        
0200                    CAN3CTL0:        equ REGBASE+$200 ;can3 control register 0
0201                    CAN3CTL1:        equ REGBASE+$201 ;can3 control register 1
0202                    CAN3BTR0:        equ REGBASE+$202 ;can3 bus timing register 0
0203                    CAN3BTR1:        equ REGBASE+$203 ;can3 bus timing register 1
0204                    CAN3RFLG:        equ REGBASE+$204 ;can3 receiver flags
0205                    CAN3RIER:        equ REGBASE+$205 ;can3 receiver interrupt enables
0206                    CAN3TFLG:        equ REGBASE+$206 ;can3 transmit flags
0207                    CAN3TIER:        equ REGBASE+$207 ;can3 transmit interrupt enables
0208                    CAN3TARQ:        equ REGBASE+$208 ;can3 transmit message abort control
0209                    CAN3TAAK:        equ REGBASE+$209 ;can3 transmit message abort status
020a                    CAN3TBEL:        equ REGBASE+$20a ;can3 transmit buffer select
020b                    CAN3IDAC:        equ REGBASE+$20b ;can3 identfier acceptance control
                        
020e                    CAN3RERR:        equ REGBASE+$20e ;can3 receive error counter
020f                    CAN3TERR:        equ REGBASE+$20f ;can3 transmit error counter
0210                    CAN3IDA0:        equ REGBASE+$210 ;can3 identifier acceptance register 0
0211                    CAN3IDA1:        equ REGBASE+$211 ;can3 identifier acceptance register 1
0212                    CAN3IDA2:        equ REGBASE+$212 ;can3 identifier acceptance register 2
0213                    CAN3IDA3:        equ REGBASE+$213 ;can3 identifier acceptance register 3
0214                    CAN3IDM0:        equ REGBASE+$214 ;can3 identifier mask register 0
0215                    CAN3IDM1:        equ REGBASE+$215 ;can3 identifier mask register 1
0216                    CAN3IDM2:        equ REGBASE+$216 ;can3 identifier mask register 2
0217                    CAN3IDM3:        equ REGBASE+$217 ;can3 identifier mask register 3
0218                    CAN3IDA4:        equ REGBASE+$218 ;can3 identifier acceptance register 4
0219                    CAN3IDA5:        equ REGBASE+$219 ;can3 identifier acceptance register 5
021a                    CAN3IDA6:        equ REGBASE+$21a ;can3 identifier acceptance register 6
021b                    CAN3IDA7:        equ REGBASE+$21b ;can3 identifier acceptance register 7
021c                    CAN3IDM4:        equ REGBASE+$21c ;can3 identifier mask register 4
021d                    CAN3IDM5:        equ REGBASE+$21d ;can3 identifier mask register 5
021e                    CAN3IDM6:        equ REGBASE+$21e ;can3 identifier mask register 6
021f                    CAN3IDM7:        equ REGBASE+$21f ;can3 identifier mask register 7
0220                    CAN3RXFG:        equ REGBASE+$220 ;can3 rx foreground buffer thru +$22f
0230                    CAN3TXFG:        equ REGBASE+$230 ;can3 tx foreground buffer thru +$23f
                        
0240                    PTT:                equ REGBASE+$240 ;portt data register
0241                    PTIT:                equ REGBASE+$241 ;portt input register
0242                    DDRT:                equ REGBASE+$242 ;portt direction register
0243                    RDRT:                equ REGBASE+$243 ;portt reduced drive register
0244                    PERT:                equ REGBASE+$244 ;portt pull device enable
0245                    PPST:                equ REGBASE+$245 ;portt pull polarity select
                        
0248                    PTS:                equ REGBASE+$248 ;ports data register
0249                    PTIS:                equ REGBASE+$249 ;ports input register
024a                    DDRS:                equ REGBASE+$24a ;ports direction register
024b                    RDRS:                equ REGBASE+$24b ;ports reduced drive register
024c                    PERS:                equ REGBASE+$24c ;ports pull device enable
024d                    PPSS:                equ REGBASE+$24d ;ports pull polarity select
024e                    WOMS:                equ REGBASE+$24e ;ports wired or mode register
                        
0250                    PTM:                equ REGBASE+$250 ;portm data register
0251                    PTIM:                equ REGBASE+$251 ;portm input register
0252                    DDRM:                equ REGBASE+$252 ;portm direction register
0253                    RDRM:                equ REGBASE+$253 ;portm reduced drive register
0254                    PERM:                equ REGBASE+$254 ;portm pull device enable
0255                    PPSM:                equ REGBASE+$255 ;portm pull polarity select
0256                    WOMM:                equ REGBASE+$256 ;portm wired or mode register
0257                    MODRR:                equ REGBASE+$257 ;portm module routing register
                        
0258                    PTP:                equ REGBASE+$258 ;portp data register
0259                    PTIP:                equ REGBASE+$259 ;portp input register
025a                    DDRP:                equ REGBASE+$25a ;portp direction register
025b                    RDRP:                equ REGBASE+$25b ;portp reduced drive register
025c                    PERP:                equ REGBASE+$25c ;portp pull device enable
025d                    PPSP:                equ REGBASE+$25d ;portp pull polarity select
025e                    PIEP:                equ REGBASE+$25e ;portp interrupt enable register
025f                    PIFP:                equ REGBASE+$25f ;portp interrupt flag register
                        
0260                    PTH:                equ REGBASE+$260 ;porth data register
0261                    PTIH:                equ REGBASE+$261 ;porth input register
0262                    DDRH:                equ REGBASE+$262 ;porth direction register
0263                    RDRH:                equ REGBASE+$263 ;porth reduced drive register
0264                    PERH:                equ REGBASE+$264 ;porth pull device enable
0265                    PPSH:                equ REGBASE+$265 ;porth pull polarity select
0266                    PIEH:                equ REGBASE+$266 ;porth interrupt enable register
0267                    PIFH:                equ REGBASE+$267 ;porth interrupt flag register
                        
0268                    PTJ:                equ REGBASE+$268 ;portj data register
0269                    PTIJ:                equ REGBASE+$269 ;portj input register
026a                    DDRJ:                equ REGBASE+$26a ;portj direction register
026b                    RDRJ:                equ REGBASE+$26b ;portj reduced drive register
026c                    PERJ:                equ REGBASE+$26c ;portj pull device enable
026d                    PPSJ:                equ REGBASE+$26d ;portj pull polarity select
026e                    PIEJ:                equ REGBASE+$26e ;portj interrupt enable register
026f                    PIFJ:                equ REGBASE+$26f ;portj interrupt flag register
                        
0280                    CAN4CTL0:        equ REGBASE+$280 ;can4 control register 0
0281                    CAN4CTL1:        equ REGBASE+$281 ;can4 control register 1
0282                    CAN4BTR0:        equ REGBASE+$282 ;can4 bus timing register 0
0283                    CAN4BTR1:        equ REGBASE+$283 ;can4 bus timing register 1
0284                    CAN4RFLG:        equ REGBASE+$284 ;can4 receiver flags
0285                    CAN4RIER:        equ REGBASE+$285 ;can4 receiver interrupt enables
0286                    CAN4TFLG:        equ REGBASE+$286 ;can4 transmit flags
0287                    CAN4TIER:        equ REGBASE+$287 ;can4 transmit interrupt enables
0288                    CAN4TARQ:        equ REGBASE+$288 ;can4 transmit message abort control
0289                    CAN4TAAK:        equ REGBASE+$289 ;can4 transmit message abort status
028a                    CAN4TBEL:        equ REGBASE+$28a ;can4 transmit buffer select
028b                    CAN4IDAC:        equ REGBASE+$28b ;can4 identfier acceptance control
                        
028e                    CAN4RERR:        equ REGBASE+$28e ;can4 receive error counter
028f                    CAN4TERR:        equ REGBASE+$28f ;can4 transmit error counter
0290                    CAN4IDA0:        equ REGBASE+$290 ;can4 identifier acceptance register 0
0291                    CAN4IDA1:        equ REGBASE+$291 ;can4 identifier acceptance register 1
0292                    CAN4IDA2:        equ REGBASE+$292 ;can4 identifier acceptance register 2
0293                    CAN4IDA3:        equ REGBASE+$293 ;can4 identifier acceptance register 3
0294                    CAN4IDM0:        equ REGBASE+$294 ;can4 identifier mask register 0
0295                    CAN4IDM1:        equ REGBASE+$295 ;can4 identifier mask register 1
0296                    CAN4IDM2:        equ REGBASE+$296 ;can4 identifier mask register 2
0297                    CAN4IDM3:        equ REGBASE+$297 ;can4 identifier mask register 3
0298                    CAN4IDA4:        equ REGBASE+$298 ;can4 identifier acceptance register 4
0299                    CAN4IDA5:        equ REGBASE+$299 ;can4 identifier acceptance register 5
029a                    CAN4IDA6:        equ REGBASE+$29a ;can4 identifier acceptance register 6
029b                    CAN4IDA7:        equ REGBASE+$29b ;can4 identifier acceptance register 7
029c                    CAN4IDM4:        equ REGBASE+$29c ;can4 identifier mask register 4
029d                    CAN4IDM5:        equ REGBASE+$29d ;can4 identifier mask register 5
029e                    CAN4IDM6:        equ REGBASE+$29e ;can4 identifier mask register 6
029f                    CAN4IDM7:        equ REGBASE+$29f ;can4 identifier mask register 7
02a0                    CAN4RXFG:        equ REGBASE+$2a0 ;can4 rx foreground buffer thru +$2af
02b0                    CAN4TXFG:        equ REGBASE+$2b0 ;can4 tx foreground buffer thru +$2bf
                        
                        * end registers
                        #endinclude

                        
                        ;------------------------------------------------------------------------------
                        ;                       Declaraciones
                        ;------------------------------------------------------------------------------
                        
                                        ;Estructuras de datos:
1000                                    org $1000
1000                    Banderas:       ds 1  ; X:X:X:CambMod:ModActual:ARRAY_OK: TCL_LEIDA:TCL_LISTA
1001 02                 MAX_TCL:        db 2  ; Datos m�ximos
1002                    Tecla:          ds 1  ; Espacio para dato leido
1003                    Tecla_IN:       ds 1  ; Guarda el dato para formar el array
1004                    Cont_Reb:       ds 1
1005                    Cont_TCL:       ds 1  ; Llevar cuenta de n�mero de teclas
1006                    Patron:         ds 1  ; Recorrer el teclado
1007                    Num_Array:      ds 2  ; array de datos
1009                    CUENTA:         ds 1
100a                    AcmPQ:          ds 1
100b                    CantPQ:         ds 1
100c                    TIMER_CUENTA:   ds 1
100d                    LEDS:           ds 1
100e                    BRILLO:         ds 1
100f                    CONT_DIG:       ds 1
1010                    CONT_TICKS:     ds 1
1011                    DT:             ds 1
1012                    BIN1:           ds 1
1013                    BIN2:           ds 1
1014                    BCD_L:          ds 1
1015                    LOW:            ds 1
1016 00                 VMAX:           db 0
1017                    TEMP:           ds 1
1018                    BCD1:           ds 1
1019                    BCD2:           ds 1
101a                    DISP1:          ds 1
101b                    DISP2:          ds 1
101c                    DISP3:          ds 1
101d                    DISP4:          ds 1
101e                    CONT_7SEG:      ds 2
1020                    Cont_Delay:     ds 1
                        ; constantes
1021 64                 D2mS:           db 100
1022 0d                 D260uS:         db 13
1023 02                 D40uS:          db 2
1024 01                 CLEAR_LCD:      db $01
1025 80                 ADD_L1:         db $80
1026 c0                 ADD_L2:         db $C0
                        
                        
1030                                    org $1030
1030 01 02 03 04 05 06  Teclas:         db $01,$02,$03,$04,$05,$06,$07,$08,$09,$0B,$00,$0E ; Posibles teclas
     07 08 09 0b 00 0e
                        
                        
1040                                    org $1040
1040 3f 06 5b 4f 66 6d  SEGMENT:        db $3F,$06,$5B,$4F,$66,$6D,$7D,$07,$7F,$6F
     7d 07 7f 6f
                        
                        
1050                                    org $1050
1050 04 28 28 06 0c     iniDsp:         db 4,FUNCTION_SET,FUNCTION_SET,ENTRY_MODE_SET,DISPLAY_ON
                        
                        ; MENSAJES Y CONSTANTES
1060                                    org $1060
                                        
1060 4d 4f 44 4f 20 43  CONFIG_MSG1:    fcc "MODO CONFIG"
     4f 4e 46 49 47
106b 00                                 db $00
106c 49 6e 67 72 65 73  CONFIG_MSG2:    fcc "Ingrese CantPQ:"
     65 20 43 61 6e 74
     50 51 3a
107b 00                                 db $00
107c 4d 4f 44 4f 20 52  RUN_MSG1:       fcc "MODO RUN"
     55 4e
1084 00                                 db $00
1085 41 63 6d 50 51 20  RUN_MSG2:       fcc "AcmPQ   CUENTA"
     20 20 43 55 45 4e
     54 41
1093 00                                 db $00
                                        
                        ;LCD:
0028                    FUNCTION_SET:   equ $28
0006                    ENTRY_MODE_SET: equ $06
000c                    DISPLAY_ON:     equ $0C
0001                    CLEAR_DISPLAY:  equ $01
0002                    RETURN_HOME:    equ $02
0080                    DDRAM_ADDR1:    equ $80
00c0                    DDRAM_ADDR2:    equ $C0
0000                    EOM:            equ $00
                        
                        
                        
                        ; Vectores para interrupciones
3e70                                    org $3E70
3e70 24 4e                              dw RTI_ISR
3e4c                                    org $3E4C
3e4c 24 5d                              dw PH0_ISR
3e66                                    org $3e66
3e66 22 69                              dw OC4_ISR
                        
                        ;------------------------------------------------------------------------------
                        ;                       PROGRAMA
                        ;------------------------------------------------------------------------------
                        
2000                                    org $2000
                        
2000 4c 38 80                                   bset CRGINT,$80                 ; Habilita RTI
2003 1c 02 66 0c                                bset PIEH,$0C                   ; se habilita keywakeup en puerto H
2007 1d 02 65 ff                                bclr PPSH,$FF                   ; flanco decreciente en portH
                        
200b 4c 0c 01                                   bset PUCR,$01                   ; Activa resistencias pull-up en PORTA
200e 18 0b 17 00 3b                             movb #$17,RTICTL                ; periodo de aprox 1ms (1.024ms)
2013 18 0b f0 00 02                             movb #$F0,DDRA                  ; parte alta de A como salida y parte baja como entrada para matriz
2018 18 0b ff 00 03                             MOVB #$FF,DDRB ;puerto core B se configura como salida de proposito general. (LEDS y SEGMENTOS)
201d 18 0b 0f 02 5a                                 MOVB #$0F,DDRP ;parte baja de puerto P se configura como salida de proposito general. (~Habilitador Segmentos)
2022 1c 02 6a 02                                    BSET DDRJ %00000010 ;se configura bit 1 del puerto J como salida de proposito general . (~Habilitador LEDS)
                        
                        ;Configuracion de la salida SAL: relay en puerto PORTE4.
2026 18 0b 04 00 09                                 MOVB #$04,DDRE ;se configura PORTE4 como salida
                        
                        ;Configuracion de pantalla LCD
202b 18 0b ff 00 33                                 MOVB #$FF,DDRK ;todos los pines del puerto K se configura como salida para controlar la LCD.
                        
                        
                                        
                                        ;Modulo timer
2030 4c 46 80                               bset TSCR1 %10000000 ;se habilita modulo de timer.
2033 4c 4d 04                               bset TSCR2 %00000100 ;prescaler es 2^3 = 8
2036 4c 40 10                               bset TIOS %00010000 ;se configura el canal 4 como Output Compare.
2039 4c 4c 10                               bset TIE %00010000 ;se habilita interrupcion del canal 4.
203c 4d 48 03                               bclr TCTL1 3 ;no es necesario que haya una salida en puerto T. Solo se requiere la interrupcion.
                        
203f cf 3b ff                           Lds #$3BFF                      ; stack
2042 10 ef                              Cli
                        ;Inicializacion de variables y banderas
                        ;------------------------------------------------------------------------------
                        
                                ; Se borran las variables de inter�s
2044 79 10 04                                   Clr Cont_Reb
2047 79 10 05                                   Clr Cont_TCL
204a 79 10 06                                   Clr Patron
204d 79 10 00                                   Clr Banderas
2050 79 10 1e                                   clr CONT_7SEG
2053 79 10 10                                   clr CONT_TICKS
2056 79 10 0f                                   clr CONT_DIG
2059 79 10 18                                   clr BCD1
205c 79 10 19                                   clr BCD2
205f 79 10 0b                                   clr CantPQ
2062 79 10 09                                   clr CUENTA
2065 79 10 0a                                   clr AcmPQ
                                        
                                ; Se llena num array con FFs
2068 b6 10 01                                   Ldaa MAX_TCL
206b ce 10 07                                   Ldx #Num_Array
                        
206e                    fill_array:
206e 18 08 30 ff                                Movb #$FF,1,X+
2072 04 30 f9                                   Dbne a, fill_array
                                
2075 18 0b 32 10 0e                             movb #50,BRILLO
207a 18 0b 02 10 0d                             movb #$02,LEDS   ; conf de leds como salida
                                        ;tecla y tecla_in se cargan en FF, valor vac�o
207f 18 0b ff 10 02                             Movb #$FF, Tecla
2084 18 0b ff 10 03                             Movb #$FF, Tecla_IN
2089 18 0c 10 40 10 1c                          movb SEGMENT,DISP3
208f 18 0c 10 40 10 1d                          movb SEGMENT,DISP4 ; PANTALLAS MOSTRANDO 0
                        
                        ;-------------------------------------------------------------------------------
                        ;INICIALIZACI�N DE PANTALLA LCD y OC4
                        ;-------------------------------------------------------------------------------
2095 dc 44                                      ldd TCNT
2097 c3 00 1e                                   addd #30 ; preesc 8
209a 5c 58                                      std TC4
                        
209c ce 10 50                                   ldx #iniDsp
209f 08                                         inx
20a0 c7                                         clrb
                                                
20a1 a6 e5              INITIALIZE_LCD:         ldaa b,x
20a3 16 22 03                                   jsr Send_Command
20a6 18 0c 10 23 10 20                          movb D40us,Cont_Delay
20ac 16 22 63                                   jsr Delay
20af 52                                         incb
20b0 f1 10 50                                   cmpb iniDsp
20b3 26 ec                                      bne INITIALIZE_LCD
20b5 b6 10 24                                   ldaa CLEAR_LCD
20b8 16 22 03                                   jsr Send_Command
20bb 18 0c 10 21 10 20                          movb D2ms,Cont_Delay
20c1 16 22 63                                   jsr Delay
                        
                        
                        ;-------------------------------------------------------------------------------
                        ;-------------------------------------------------------------------------------
                        ;-------------------------------------------------------------------------------
                        ;-------------------------------------------------------------------------------
                        ;-------------------------------------------------------------------------------
                        ;-------------------------------------------------------------------------------
                        
                        
20c4 1c 10 00 10                                bset Banderas,$10 ; Se entra en modo config X:X:X:CambMod:ModActual:ARRAY_OK: TCL_LEIDA:TCL_LISTA
                        
20c8 f7 10 0b           MAIN_LOOP:              tst CantPQ
20cb 27 58                                      beq ESTADO_ZERO
                        
                                                ;Revisamos si modsel==modactual
                        
20cd 1e 10 00 08 0f                             Brset Banderas %00001000 MODSEL1 ;se revisa si MODSEL esta en 1
                                                ;Caso de MODSEL==0
20d2 1f 02 61 80 22                             Brclr PTIH %10000000 CONFIG_MODE ;MODSEL es 0, se verifica por modo RUN
20d7 1d 10 00 08                                Bclr Banderas %00001000 ;MODSEL es 0, se pone ModActual en Banderas en
20db 1c 10 00 10                                Bset Banderas %00010000
20df 20 09                                      Bra CLEAN_SCREEN
20e1                    MODSEL1:
20e1 1e 02 61 80 13                                    Brset PTIH %10000000 CONFIG_MODE ;MODSEL es 1, se verifica por modo CONFIG
20e6 1c 10 00 18                                Bset Banderas %00011000 ;Se actualiza modsel y se pone en uno el cambio
                        
                                                ;MAE SINCERAMENTE ESTA PARTE NO SE SI ES NECESARIA
                                                ;NO VIENE EN EL DIAGRAMA PERO VICTOR LO METIO EN LO DE EL
20ea b6 10 24           CLEAN_SCREEN            LDAA CLEAR_LCD ;cuando se cambia de modo, se limpia la pantalla
20ed 16 22 03                                   JSR Send_Command ;envio de comando de limpieza de pantalla
20f0 18 0c 10 21 10 20                          MOVB D2ms,Cont_Delay ;luego de enviar comando limpiar pantalla se debe esperar 2ms
20f6 16 22 63                                   JSR Delay
                        
20f9 1e 10 00 08 2b     CONFIG_MODE:            Brset Banderas,$8 CONFIG_LCD
                        
                        
20fe 1f 10 00 10 1c     CONFIG_RUN:                brclr Banderas,$10,CALL_RUN
                        
2103 1c 02 66 03                                bset PIEH,$03     ;se habilitan puertos H 0 y 1
2107 1d 10 00 10                                bclr Banderas,$10  ;CAMBIO DE MOD EN 0
                        
210b ce 10 7c                                   ldx #RUN_MSG1
210e cd 10 85                                   ldy #RUN_MSG2
                        
2111 18 0b 01 10 0d                             movb #$01,LEDS ; enciende led pb0
                        
2116 ce 10 60                                   ldx #CONFIG_MSG1
2119 cd 10 6c                                   ldy #CONFIG_MSG2
                        
                        
                                                ; CONFIGURACION PREVIA AL LCD, en primera iter entra ac�
                        
211c 16 21 bc                                   jsr CARGAR_LCD
                        
211f 16 24 16           CALL_RUN:               jsr MODO_RUN
2122 06 20 c8                                   jmp MAIN_LOOP
                        
                        
                        ;-------------------------------------------------------------------------------
                        
                        
2125 1c 10 00 08        ESTADO_ZERO:            bset Banderas,$08
                        
2129 4c 38 80           CONFIG_LCD:             bset CRGINT,$80 ;NO ES NECESARIA, CRGINT YA HABILITADAS
212c 1f 10 00 10 2b                             brclr Banderas,$10,CALL_CONFIG  ; Entra SOLO en primera iteraci�n
2131 1d 10 00 10                                bclr Banderas,$10 ; se pone cambio de modo en 0
                                                
2135 1d 02 66 03                                bclr PIEH,$03     ;se deshabilitan puertos H 0 y 1
2139 1d 10 00 10                                bclr Banderas,$10
                                                
213d ce 10 60                                   ldx #CONFIG_MSG1
2140 cd 10 6c                                   ldy #CONFIG_MSG2
                                                
2143 79 10 09                                   clr CUENTA
2146 79 10 0a                                   clr AcmPQ
                        
2149 18 0b 00 00 08                             movb #$00,PORTE
214e 18 0b 02 10 0d                             movb #$02,LEDS ; enciende led pb1
                                                
2153 18 0c 10 0b 10 12                          movb CantPQ,BIN1
                                        
                                                ; CONFIGURACION PREVIA AL LCD, en primera iter entra ac�
                                        
2159 16 21 bc                                   jsr CARGAR_LCD
                                        
                        
                        
215c 16 21 62           CALL_CONFIG:            jsr MODO_CONFIG
                        
                        
215f 06 20 c8           volver_main:            jmp MAIN_LOOP
                        
                        
                        
                        ;-------------------------------------------------------------------------------
                        
2162 18 0c 10 0b 10 12  MODO_CONFIG:            movb CantPQ, BIN1
2168 1e 10 00 04 04                             brset Banderas,$04,DATA_CHECK
216d 16 23 28                                   jsr TAREA_TECLADO
2170 3d                                         rts
                        
                        
2171 16 21 98           DATA_CHECK:             jsr BCD_BIN
2174 86 19                                      ldaa #25
2176 b1 10 0b                                   cmpa CantPQ
2179 2e 07                                      bgt INVALIDO
217b 86 55                                      ldaa #85
217d b1 10 0b                                   cmpa CantPQ
2180 2c 09                                      bge VALIDO
                        
2182 1d 10 00 04        INVALIDO:               bclr Banderas,$04
2186 1d 10 0b ff                                bclr CantPQ,$FF
218a 3d                                         rts
                                        
218b 1d 10 00 04        VALIDO:                        bclr Banderas, $04
218f 18 0c 10 0b 10 12                          movb CantPQ,BIN1
2195 3d                                         rts
                                        
                                        
                        
                                        
2196 20 fe              ending: bra *
                        ;-------------------------------------------------------------------------------
                        
2198 ce 10 07           BCD_BIN:        ldx #Num_Array
219b e6 01                              ldab 1,x
219d c1 ff                              cmpb #$FF
219f 27 05                              beq UNIDAD
21a1 7b 10 0b                           stab CantPQ
21a4 20 07                              bra DECENA
                                        
21a6 18 0c 10 07 10 0b  UNIDAD:         movb Num_Array,CantPQ
21ac 3d                                 rts
                        
21ad 87                 DECENA:                clra
21ae f6 10 07                           ldab Num_Array
21b1 cd 00 0a                           ldy #10
21b4 13                                 emul
                        
21b5 fb 10 0b                           addb CantPQ
21b8 7b 10 0b                           stab CantPQ
                        
21bb 3d                                 rts
                        ;-------------------------------------------------------------------------------
21bc b6 10 25           Cargar_LCD:     ldaa ADD_L1
21bf 16 22 03                           jsr Send_Command
21c2 18 0c 10 23 10 20                  movb D40uS,Cont_Delay
21c8 16 22 63                           jsr Delay
                                        
21cb a6 30              LINEA1:         ldaa 1,x+ ;Se va cargando mensaje
21cd 81 00                              cmpa #$00
21cf 27 0e                              beq CARGAR_LINEA2
                                        
21d1 16 22 36                           jsr Send_Data
                                        
21d4 18 0c 10 23 10 20                  movb D40uS,Cont_Delay
21da 16 22 63                           jsr Delay
21dd 20 ec                              bra LINEA1
                                        
                                        
21df b6 10 26           CARGAR_LINEA2:  ldaa ADD_L2
21e2 16 22 03                           jsr Send_Command
21e5 18 0c 10 23 10 20                  movb D40uS,Cont_Delay
21eb 16 22 63                           jsr Delay
                        
                        
21ee a6 70              LINEA2:         ldaa 1,y+
21f0 81 00                              cmpa #$00
21f2 27 0e                              beq TERMINA_LCD
21f4 16 22 36                           jsr Send_Data
21f7 18 0c 10 23 10 20                  movb D40uS,Cont_Delay
21fd 16 22 63                           jsr Delay
2200 20 ec                              bra LINEA2
                        
2202 3d                 TERMINA_LCD:           rts
                        
                        ;-------------------------------------------------------------------------------
2203 36                 Send_Command:   psha
2204 84 f0                              anda #$F0
2206 44                                 lsra
2207 44                                 lsra
                        
2208 5a 32                              staa PORTK
220a 4d 32 01                           bclr PORTK,$01
220d 4c 32 02                           bset PORTK,$02
                        
2210 18 0c 10 22 10 20                  movb D260uS,Cont_Delay
2216 16 22 63                           jsr Delay
                        
2219 4d 32 02                           bclr PORTK,$02
221c 32                                 pula
221d 84 0f                              anda #$0F
221f 48                                 lsla
2220 48                                 lsla
                        
2221 5a 32                              staa PORTK
2223 4d 32 01                           bclr PORTK,$01
2226 4c 32 02                           bset PORTK,$02
                        
2229 18 0c 10 22 10 20                  movb D260uS,Cont_Delay
222f 16 22 63                           jsr Delay
                        
2232 4d 32 02                           bclr PORTK,$02
2235 3d                                 rts
                                        
                        
2236                    Send_Data:
2236 36                                 PSHA ;el dato se recibe en acumulador A y se protege para poder analizar sus nibbles por separado
2237 84 f0                              ANDA #$F0 ;Se deja solo el nibble superior del dato
2239 44                                 LSRA
223a 44                                 LSRA ;se alinea nibble con bus datos en PORTK5-PORTK2.
223b 5a 32                              STAA PORTK ;se carga parte alta del dato en el bus de datos.
223d 4c 32 03                           BSET PORTK,$03 ;Se habilita el envio de dato y comunicacion con la LCD
2240 18 0c 10 22 10 20                  MOVB D260us,Cont_Delay ;se inicia el retardo de 260us
2246 16 22 63                           JSR Delay
2249 4d 32 02                           BCLR PORTK,$02 ;Se deshabilita comunicacion con la LCD
224c 32                                 PULA ;se recupera el dato original de la pila
224d 84 0f                              ANDA #$0F ;Se deja solo el nibble inferior del dato
224f 48                                 LSLA
2250 48                                 LSLA ;se alinea nibble con bus datos en PORTK5-PORTK2.
2251 5a 32                              STAA PORTK ;se carga parte baja del dato en el bus de datos.
2253 4c 32 03                           BSET PORTK,$03 ;Se habilita envio de datos y comunicacion con la LCD
2256 18 0c 10 22 10 20                  MOVB D260us,Cont_Delay ;se inicia el retardo de 260us.
225c 16 22 63                           JSR Delay
225f 4d 32 02                           BCLR PORTK,$02 ;Se deshabilita comunicacion con la LCD
2262 3d                                 RTS
                        
                        
                        
                        ;-------------------------------------------------------------------------------
2263 f7 10 20           Delay:  tst Cont_Delay
2266 26 fb                      bne Delay
2268 3d                         rts
                        
                        ;-------------------------------------------------------------------------------
2269 f7 10 20           OC4_ISR:        tst Cont_Delay
226c 27 03                              beq REFRESH
226e 73 10 20                           dec Cont_Delay
                        
2271                    REFRESH:
2271 fc 10 1e                           LDD CONT_7SEG ;por tratarse de un WORD se debe traer al registro D para restarle 1
2274 83 00 01                           SUBD #1
2277 7c 10 1e                           STD CONT_7SEG ;se guarda el nuevo valor, y esto a la vez afecta la bandera Z
227a 26 0c                              BNE SELECT_DISP ;cuando CONT_7SEG=0 se refrescan los valores de los displays
227c 18 03 13 88 10 1e                  MOVW #5000,CONT_7SEG ;se reinicia el contador de refrescamiento de la informacion
2282 16 24 ea                           JSR CONV_BIN_BCD
2285 16 24 76                           JSR BCD_7SEG ;se refresca la informacion
2288                    SELECT_DISP:
2288 86 64                              LDAA #100
228a b1 10 10                           CMPA CONT_TICKS ;cuando CONT_TICKS=N se debe cambiar de digito
228d 26 10                              BNE MULTIPLEX ;si no es igual entonces no hay que cambiar de digito y se puede continuar
228f 79 10 10                           CLR CONT_TICKS ;se reinicia el contador de ticks
2292 72 10 0f                           INC CONT_DIG ;se pasa al siguiente digito
2295 86 05                              LDAA #5
2297 b1 10 0f                           CMPA CONT_DIG ;cuando CONT_DIG alcance 5 se debe volver a colocar en 0 para que sea circular
229a 26 03                              BNE MULTIPLEX ;si no es 5 no hay que corregir nada y se puede continuar
229c 79 10 0f                           CLR CONT_DIG
229f                    MULTIPLEX:
229f 86 64                              LDAA #100
22a1 b0 10 0e                           SUBA BRILLO
22a4 7a 10 11                           STAA DT
22a7 f7 10 10                           TST CONT_TICKS
22aa 26 5c                              BNE DUTY_CYCLE ;cuando CONT_TICKS=0 se debe habiliar algun Display. Si no, se puede pasar a comprobar el ciclo de trabajo
22ac 18 0b 02 02 68                     MOVB #$02,PTJ ;se deshabilitan los LEDS
22b1 18 0b ff 02 58                     MOVB #$FF,PTP ;se deshabilitan displays de 7 segmentos
22b6 b6 10 0f                           LDAA CONT_DIG ;se comparan todos los posibles valores para determinar cual display encender
22b9 81 00                              CMPA #0
22bb 27 19                              BEQ DIG0
22bd 81 01                              CMPA #1
22bf 27 22                              BEQ DIG1
22c1 81 02                              CMPA #2
22c3 27 2b                              BEQ DIG2
22c5 81 03                              CMPA #3
22c7 27 34                              BEQ DIG3
                                        ;Ningun Display se debe habilitar, entonces son los LEDS
22c9 18 0b 00 02 68                     MOVB #$00,PTJ ;se habilitan los LEDS
22ce 18 0c 10 0d 00 01                  MOVB LEDS,PORTB ;se coloca en puerto B el estado de los LEDS.
22d4 20 32                              BRA DUTY_CYCLE ;se pasa a comprobar el ciclo de trabajo
22d6                    DIG0:
22d6 18 0b f7 02 58                     MOVB #$F7,PTP ;se habilita unicamente el display 4
22db 18 0c 10 1d 00 01                  MOVB DISP4,PORTB ;se coloca en el puerto B el valor del display 4
22e1 20 25                              BRA DUTY_CYCLE
22e3                    DIG1:
22e3 18 0b fb 02 58                     MOVB #$FB,PTP ;se habilita unicamente el display 3
22e8 18 0c 10 1c 00 01                  MOVB DISP3,PORTB ;se coloca en el puerto B el valor del display 3
22ee 20 18                              BRA DUTY_CYCLE
22f0                    DIG2:
22f0 18 0b fd 02 58                     MOVB #$FD,PTP ;se habilita unicamente el display 2
22f5 18 0c 10 1b 00 01                  MOVB DISP2,PORTB ;se coloca en el puerto B el valor del display 2
22fb 20 0b                              BRA DUTY_CYCLE
22fd                    DIG3:
22fd 18 0b fe 02 58                     MOVB #$FE,PTP ;se habilita unicamente el display 1
2302 18 0c 10 1a 00 01                  MOVB DISP1,PORTB ;se coloca en el puerto B el valor del display 1
2308                    DUTY_CYCLE:
2308 b6 10 10                           LDAA CONT_TICKS
230b b1 10 11                           CMPA DT
230e 26 0a                              BNE FIN_OC4
2310 18 0b ff 02 58                     MOVB #$FF,PTP ;se deshabilitan displays de 7 segmentos
2315 18 0b 02 02 68                     MOVB #$02,PTJ ;se deshabilitan los LEDS
231a                    FIN_OC4:
231a 72 10 10                           INC CONT_TICKS
231d 4c 4e 10                           BSET TFLG1 %00010000 ;se reinicia la bandera de interrupcion
2320 dc 44                              LDD TCNT ;se carga el valor actual de TCNT para reajustar el output compare
2322 c3 00 3c                           ADDD #60 ;60 cuentas equivalen 50kHz con prescalador=8
2325 5c 58                              STD TC4 ;se actualiza el nuevo valor a alcanzar.
2327 0b                                 RTI
                        
                        ;-------------------------------------------------------------------------------
                        
                        ;-------------------------------------------------------------------------------
2328                    TAREA_TECLADO:
2328 b6 10 04                   Ldaa Cont_Reb
232b 81 00                      Cmpa #0
232d 26 4a                      Bne RETORNAR
232f 16 23 7a                   Jsr MUX_TECLADO
2332 b6 10 02                   Ldaa Tecla
2335 81 ff                      Cmpa #$FF
2337 26 0e                      Bne PRESIONADA
2339 1f 10 00 01 3b             Brclr Banderas,$01,RETORNAR                 ; Si TCL_LISTA es 0, no hay tecla que registrar por lo que se termina la subrutina
233e 1d 10 00 03                Bclr Banderas,#$03                         ; Caso contrario se registra la tecla. Se ponen en 0 TCL_LISTA y TCL_LEIDA para la siguiente tecla
2342 16 23 b0                   Jsr FORMAR_ARRAY
2345 20 32                      Bra RETORNAR
                        
2347                    PRESIONADA:
2347 1f 10 00 02 0e             Brclr Banderas,$02,NotProc
234c b6 10 03                   Ldaa Tecla_IN
234f b1 10 02                   Cmpa Tecla
2352 26 17                      Bne Delete
2354 1c 10 00 01                Bset Banderas,$01                         ; La tecla esta lista para registro
2358 20 1f                      bra RETORNAR
                        
                        
                        
235a                    NotProc:
235a 18 0c 10 02 10 03          Movb Tecla, Tecla_IN
2360 1c 10 00 02                Bset Banderas, #2
2364 18 0b 0a 10 04             Movb #10,Cont_Reb
2369 20 0e                      Bra RETORNAR
                        
236b 18 0b ff 10 02     DELETE: Movb #$FF,Tecla
2370 18 0b ff 10 03             Movb #$FF,Tecla_IN
2375 1d 10 00 03                Bclr Banderas, #3
                        
2379                    RETORNAR:
2379 3d                         RTS
                        
                        
                        ;------------------------------------------------------------------------------
237a 18 0b ef 10 06     MUX_TECLADO:    movb #$EF,Patron                ; Patron inicial
237f cc f0 00                           ldd #$F000                       ; final cuando se desplaza patron
                        
2382 18 0c 10 06 00 00  BUSCAR_COLUMNA: movb Patron,PORTA
2388 4f 00 08 18                        brclr PORTA,$08,columna2            ; Verificamos se la tecla est� en la columna2
238c 4f 00 04 15                        brclr PORTA,$04,columna1
2390 4f 00 02 12                        brclr PORTA,$02,columna0
2394 78 10 06                           lsl Patron                          ; Se desplaza el patron para verificar siguiente fila
2397 cb 03                              addb #3                             ; Se suman 3 para aumentar esa cantidad en el array de posibilidades
2399 b1 10 06                           cmpa Patron
239c 26 e4                              bne BUSCAR_COLUMNA
239e 18 0b ff 10 02                     movb #$FF,Tecla
23a3 3d                 TERMINAR:       rts
                        
23a4 52                 columna2:       incb                                ; Incrementa en 2 si salta ac�
23a5 52                 columna1:       incb                                ; Incrementa en 1 si salta ac�
23a6 ce 10 30           columna0:       ldx #Teclas
23a9 18 0d e5 10 02                     movb B,X,Tecla                      ; Se mueve la tecla encontrada
23ae 20 f3                              bra TERMINAR
                        
                        ;------------------------------------------------------------------------------
23b0 b6 10 03           FORMAR_ARRAY:   ldaa Tecla_IN                   ; valor ingresado
23b3 f6 10 05                           ldab Cont_TCL                   ; cantidad de numeros
23b6 ce 10 07                           ldx #Num_Array                   ; Posici�n del array
                        
23b9 f1 10 01                           cmpb MAX_TCL                    ; comparamos si ya est� lleno
23bc 27 13                              beq ARRAY_LLENO
23be c1 00                              cmpb #0                         ; vemos si est� vac�o
23c0 27 2a                              beq PRIMER_VAL
23c2 81 0b                              cmpa #$0B                       ; tecla borrar
23c4 27 42                              beq BORRAR
23c6 81 0e                              cmpa #$0E                       ; tecla enter
23c8 27 34                              beq ENTER
23ca 6a e5                              staa b,x                        ; guarda en Num_array + cont_TCL
23cc 72 10 05                           inc Cont_TCL
23cf 20 3f                              bra end_formar
                        
23d1 81 0b              ARRAY_LLENO:    cmpa #$0B
23d3 26 0a                              bne ARRAY_LLENO_1
23d5 53                                 decb
23d6 18 08 e5 ff                        movb #$FF,b,x                    ; Para borrar reemplazamos valor actual con ff
23da 73 10 05                           dec Cont_TCL
23dd 20 31                              bra end_formar
                        
23df 81 0e              ARRAY_LLENO_1:  cmpa #$0E                         ; es enter?
23e1 26 2d                              bne end_formar
23e3 1c 10 00 04                        bset Banderas,$04                ; bandera de array ok
23e7 79 10 05                           clr Cont_TCL                     ; vac�a contador tc
23ea 20 24                              bra end_formar
                        
23ec 81 0b              PRIMER_VAL:     cmpa #$0B
23ee 27 20                              beq end_formar                         ; terminar
                        
23f0 81 0e              PRIMER_VAL_1:   cmpa #$0E
23f2 27 1c                              beq end_formar
23f4 18 09 e5 10 03                     movb Tecla_IN,b,x
23f9 72 10 05                           inc Cont_TCL
23fc 20 12                              bra end_formar
                        
23fe 1c 10 00 04        ENTER:          bset Banderas,#$04                    ; bandera de array_ok
2402 1d 10 05 ff                        bclr Cont_TCL,#$FF                    ; pone contador en 0
2406 20 08                              bra end_formar
                        
                        
2408 73 10 05           BORRAR:         dec Cont_TCL
240b 53                                 decb
240c 18 08 e5 ff                        movb #$FF,b,x
                        
                        
2410 18 0b ff 10 03     end_formar:     movb #$FF,Tecla_IN
2415 3d                                 rts
                        ;-------------------------------------------------------------------------------
2416                    MODO_RUN:
2416 f7 10 0c                           Tst TIMER_CUENTA ;si timer cuenta es cero
2419 26 26                              Bne Fin_Run ;si no lo es, se retorna
                                        ;Caso en que timer cuenta es cero
241b 18 0c 10 16 10 0c                  Movb VMAX,TIMER_CUENTA ;se recarga con vmax
2421 72 10 09                           Inc CUENTA ;incrementamos cuenta
2424 b6 10 09                           Ldaa CUENTA ;
2427 b1 10 0b                           Cmpa CantPQ ;
242a 26 15                              Bne Fin_Run ;si cant!=cuenta
242c 72 10 0a                           Inc AcmPQ ;se incrementa AcmPQ
242f 4d 38 80                           Bclr CRGINT %10000000 ;se deshabilitamos RTI
2432 18 0b 04 00 08                     Movb #$04,PORTE ;se activa el relay
2437 86 64                              Ldaa #100
2439 b1 10 0a                           Cmpa AcmPQ ;se ve si AcmPQ ha llegado a 100 por rebase
243c 26 03                              Bne Fin_Run ;si no se ha llegado a 100, retorna
243e 79 10 0a                           CLR AcmPQ ;si se llega a 100, se hace rebase
2441                    Fin_Run:
2441 18 0c 10 09 10 12                  MOVB CUENTA,BIN1
2447 18 0c 10 0a 10 13                  MOVB AcmPQ,BIN2
244d 3d                                 RTS
                        
                        ;------------------------------------------------------------------------------
244e 4c 37 80           RTI_ISR:        bset CRGFLG,$80                 ; Se reinicia la bandera de interrupcion
2451 fe 10 04                           ldx Cont_Reb
2454 8e 00 00                           cpx #0
2457 27 03                              beq fin_RTI                         ; Si el contador esta en 0 no se debe decrementar
2459 73 10 04                           dec Cont_Reb
245c 0b                 fin_RTI:        rti
                        
                        ;------------------------------------------------------------------------------
245d 1c 02 67 01        PH0_ISR:        Bset PIFH,$01                         ; Se reinicia la bandera de interrupcion
2461 1d 10 00 04                        Bclr Banderas,$04
2465 79 10 05                           Clr Cont_TCL
2468 b6 10 01                           Ldaa MAX_TCL
246b ce 10 07                           Ldx #Num_Array
                        
246e 18 08 30 ff        vaciado_ph0:       Movb #$FF,1,X+                         ; Iteraci�n para vaciar array
2472 04 30 f9                           Dbne a, vaciado_ph0
                        
2475 0b                                 Rti
                                        
                                        
                        ;------------------------------------------------------------------------------
                        
2476                    BCD_7SEG:
2476 f7 10 0b                           TST CantPQ
2479 26 14                              BNE CONVERSION ;cuando CPROG es cero se deben forzar al display ambos ceros.
247b 79 10 1a                           CLR DISP1 ;apaga displays de ACUMUL
247e 79 10 1b                           CLR DISP2 ;apaga displays de ACUMUL
2481 18 0c 10 40 10 1c                  MOVB SEGMENT,DISP3 ;fuerza el cero en displays de CUENTA
2487 18 0c 10 40 10 1d                  MOVB SEGMENT,DISP4 ;fuerza el cero en displays de CUENTA. Si se quisiera poner el ultimo valor valido, se borran estas 2 lineas
248d 20 5a                              BRA FIN_BCD_7SEG
                        
248f                    CONVERSION:
248f ce 10 40                           LDX #SEGMENT ;direccion base de los valores para escribir en el puerto B.
2492 c6 0f                              LDAB #$0F ;mascara para nibble menos significativo
2494 86 f0                              LDAA #$F0 ;mascara para nibble mas significativo
2496 f4 10 18                           ANDB BCD1 ;se extrae el nibble menos significativo de BCD1.
2499 18 0d e5 10 1d                     MOVB B,X,DISP4
249e b4 10 18                           ANDA BCD1 ;se extrae el nibble mas significativo de BCD1.
24a1 81 b0                              CMPA #$B0
24a3 27 0b                              BEQ DISP3_OFF ;cuando el nibble mas significativo es $B se debe apagar el DISP3
24a5 44                                 LSRA
24a6 44                                 LSRA
24a7 44                                 LSRA
24a8 44                                 LSRA ;se traslada el nibble mas significativo a la parte baja del byte.
24a9 18 0d e4 10 1c                     MOVB A,X,DISP3
24ae 20 05                              BRA AHORA_BCD2
24b0                    DISP3_OFF:
24b0 18 0b 00 10 1c                     MOVB #$00,DISP3
                        
24b5                    AHORA_BCD2:
24b5 1e 10 00 08 25                     BRSET Banderas %00001000 NO_BCD2
24ba c6 0f                              LDAB #$0F ;mascara para nibble menos significativo
24bc 86 f0                              LDAA #$F0 ;mascara para nibble mas significativo
24be f4 10 19                           ANDB BCD2 ;se extrae el nibble menos significativo de BCD1.
24c1 18 0d e5 10 1b                     MOVB B,X,DISP2
24c6 b4 10 19                           ANDA BCD2 ;se extrae el nibble mas significativo de BCD1.
24c9 81 b0                              CMPA #$B0
24cb 27 0b                              BEQ DISP1_OFF ;cuando el nibble mas significativo es $F se debe apagar el DISP1
24cd 44                                 LSRA
24ce 44                                 LSRA
24cf 44                                 LSRA
24d0 44                                 LSRA ;se traslada el nibble mas significativo a la parte baja del byte.
24d1 18 0d e4 10 1a                     MOVB A,X,DISP1
24d6 20 11                              BRA FIN_BCD_7SEG
24d8                    DISP1_OFF:
24d8 18 0b 00 10 1a                     MOVB #$00,DISP1
24dd 20 0a                              BRA FIN_BCD_7SEG
                        
24df                    NO_BCD2:
24df 18 0b 00 10 1a                     MOVB #$00,DISP1
24e4 18 0b 00 10 1b                     MOVB #$00,DISP2
24e9                    FIN_BCD_7SEG:
24e9 3d                                 RTS
                                        
                                        
24ea                    CONV_BIN_BCD:
24ea b6 10 12                           LDAA BIN1 ;se carga parametro de entrada a BIN_BCD_BASE
24ed 16 25 18                           JSR BIN_BCD
24f0 b6 10 14                           LDAA BCD_L
24f3 81 0a                              CMPA #10
24f5 24 04                              BHS TRF_BCD1 ;si el numero es mayor o igual a 10 no hay que apagar ninguno display
24f7 8a f0                              ORAA #$F0 ;
24f9 80 40                              SUBA #$40 ;se pone $B en nibble mas significativo para indicar que el display se debe apagar.
24fb                    TRF_BCD1:
24fb 7a 10 18                           STAA BCD1 ;se guarda resultado en variable de salida
24fe 1e 10 00 08 14                     BRSET Banderas %00001000 FIN_BIN_BCD ;en modo CONFIG (ModActual=1) no es necesario convertir BIN2
2503 b6 10 13                           LDAA BIN2 ;se carga parametro de entrada a BIN_BCD
2506 16 25 18                           JSR BIN_BCD
2509 b6 10 14                           LDAA BCD_L
250c 81 0a                              CMPA #10
250e 24 04                              BHS TRF_BCD2 ;si el numero es mayor o igual a 10 no hay que apagar ninguno display
2510 8a f0                              ORAA #$F0
2512 80 40                              SUBA #$40 ;se pone $B en nibble mas significativo para indicar que el display se debe apagar. $F-$4=$B
2514                    TRF_BCD2:
2514 7a 10 19                           STAA BCD2 ;se guarda resultado en variable de salida
2517                    FIN_BIN_BCD:
2517 3d                                 RTS
                                        
                        ;------------------------------------------------------------------------------
2518 c7                 BIN_BCD:        CLRB ;acumulador para el resultado.
2519 ce 00 07                           LDX #7 ;contador de desplazamiento.
251c                    NEXT_BIT:
251c 48                                 LSLA ;se extrae un bit del numero binario y queda en C
251d 55                                 ROLB ;se inserta el bit en el acumulador de resultado
251e 36                                 PSHA ;se protege el numero en conversion
251f 18 0f                              TBA ;A ahora tiene el contenido del acumulador de resultado
2521 84 0f                              ANDA #$0F ;en el nibble menos significativo de A se tienen los 4 bits correspondientes a las unidades del resultado.
2523 81 05                              CMPA #5
2525 25 02                              BLO DECENAS ;si el campo de las unidades es menor que 5 se puede continuar a analizar las decenas
2527 8b 03                              ADDA #$03 ;cuando las unidades son 5 o mas se deben sumar 3 unidades.
2529                    DECENAS:
2529 7a 10 15                           STAA LOW ;se conservan temporalmente las unidades.
252c 18 0f                              TBA ;se vuelve a cargar en A el contenido del acumulador resultado
252e 84 f0                              ANDA #$F0 ;en el nibble mas significativo de A se tienen los 4 bits correspondientes a las decenas del resultado.
2530 81 50                              CMPA #$50
2532 25 02                              BLO CONFECCIONAR ;si el campo de las unidades es menor que 5 se puede continuar a analizar las decenas
2534 8b 30                              ADDA #$30 ;cuando las decenas son 5 o mas se deben sumar 3 decenas.
2536                    CONFECCIONAR:
2536 bb 10 15                           ADDA LOW ;se suman las unidades
2539 18 0e                              TAB ;se traslada a B el nuevo resultado parcial
253b 32                                 PULA ;se recupera el numero binario que se esta convirtiendo
253c 09                                 DEX ;se decrementa el contador de desplazamientos
253d 26 dd                              BNE NEXT_BIT ;cuando el contador no es cero significa que quedan bits por analizar.
253f 48                                 LSLA ;se extrae el ultimo bit
2540 55                                 ROLB ;se inserta el ultimo bit en el resultado final.
2541 7b 10 14                           STAB BCD_L
2544 3d                                 RTS

Executed: Thu Feb 11 00:32:51 2021
Total cycles: 1519, Total bytes: 1442
Total errors: 0, Total warnings: 0
